//glock chigga   
let awaitingReplyWord = false;
let awaitingReplyResponse = false;  // Add this line
let tempReplyWord = '';
let tempBotId = null;
const userStates = new Map();
const pendingReplies = new Map(); // { userId: { triggerWord, botId } }
// Declare ownerId at the top of your file
let ownerId = null;

// Make sure this is at the top of your file
const activeGroups = new Map();
// Add these variables at the top of your file
let awaitingBotName = false;
// Add these variables at the top of your file
let awaitingDeleteReplyWord = false;
const cloudinary = require('cloudinary').v2;
const { getLeaderboard,getUserStatistics, getDifficultyLevels, getQuestionsForDifficulty,isSecondaryDeveloper  } = require('./commands');
const chatStates = new Map();
// Add these global variables at the top of your file
const activeQuizzes = new Map(); // Map to store active quizzes by chat ID
const userScores = new Map(); // Map to store user scores
// Cloudinary configuration
cloudinary.config({
  cloud_name: 'dpxowt5m5',
  api_key: '248273337268518',
  api_secret: 'SihooJWz6cMi5bNDAU26Tmf-tIw' // Replace with your actual API secret
});
// Add this to your global variables
const quizSettings = new Map();
const { isDeveloper,isSubscribed } = require('./middlewares');
const { addQuizQuestion } = require('./database');
// Add this at the top of your file
const database = require('./database');
const { Markup } = require('telegraf');
const { updateActiveGroup } = require('./database');
// Quiz state constants
const QUIZ_STATE = {
    INACTIVE: 0,
    SELECTING_DIFFICULTY: 1,
    SELECTING_QUESTION_COUNT: 2,
    ACTIVE: 3
};


const {isAdminOrOwner,isVIP} = require('./commands');    
const axios = require('axios');
const fs = require('fs');
const path = require('path');    
// Ensure the directory for saving media exists
const mediaDir = path.join(__dirname, 'media');
if (!fs.existsSync(mediaDir)) {
    fs.mkdirSync(mediaDir);
}


// Function to download and save file
// Function to download and save file
async function saveFile(fileLink, fileName) {
    try {
        console.log(`Attempting to save file from ${fileLink} as ${fileName}`);
        
        // Ensure the media directory exists
        const mediaDir = path.join(__dirname, 'media');
        if (!fs.existsSync(mediaDir)) {
            console.log(`Creating media directory: ${mediaDir}`);
            fs.mkdirSync(mediaDir, { recursive: true });
        }
        
        // Generate a unique filename with timestamp while keeping the original extension
        const timestamp = Date.now();
        const fileExtension = path.extname(fileName);
        const fileNameWithoutExt = path.basename(fileName, fileExtension);
        const newFileName = `${fileNameWithoutExt}_${timestamp}${fileExtension}`;
        
        const filePath = path.join(mediaDir, newFileName);
        console.log(`Full file path: ${filePath}`);
        
        // Use axios to download the file
        const response = await axios({
            method: 'GET',
            url: fileLink.toString(),
            responseType: 'stream'
        });
        
        // Create a write stream and pipe the response data to it
        const writer = fs.createWriteStream(filePath);
        response.data.pipe(writer);
        
        // Return a promise that resolves when the file is fully written
        return new Promise((resolve, reject) => {
            writer.on('finish', () => {
                console.log(`File successfully saved to ${filePath}`);
                resolve({ filePath, fileName: newFileName });
            });
            writer.on('error', (err) => {
                console.error(`Error writing file to ${filePath}:`, err);
                reject(err);
            });
        });
    } catch (error) {
        console.error(`Error in saveFile function:`, error);
        throw error;
    }
}


 
async function broadcastMessage(ctx, mediaType, mediaId, caption) {
    try {
        const db = await ensureDatabaseInitialized();
        const groups = await db.collection('groups').find({ is_active: true }).toArray();

        for (const group of groups) {
            try {
                if (mediaType && mediaId) {
                    // Send media with caption
                    await ctx.telegram.sendMediaGroup(group.group_id, [{
                        type: mediaType,
                        media: mediaId,
                        caption: caption || ''
                    }]);
                } else if (caption) {
                    // Send caption only
                    await ctx.telegram.sendMessage(group.group_id, caption);
                }
            } catch (error) {
                console.error(`Error sending message to group ${group.group_id}:`, error);
            }
        }

        await ctx.reply('‚úÖ ÿ™ŸÖ ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿ•ŸÑŸâ ÿ¨ŸÖŸäÿπ ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™ ÿßŸÑŸÜÿ¥ÿ∑ÿ©.');
    } catch (error) {
        console.error('Error in broadcastMessage:', error);
        await ctx.reply('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ŸÖÿ≠ÿßŸàŸÑÿ© ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©.');
    }
}
// Consolidated media handler function
async function handleMediaMessage(ctx, mediaType) {
    try {
        if (!awaitingReplyResponse || !tempReplyWord) {
            console.log('Not awaiting a reply response or no temp word set');
            return false;
        }

        console.log(`Handling ${mediaType} message for trigger word: ${tempReplyWord}`);
        const userId = ctx.from.id;
        const username = ctx.from.username || '';
        let fileId, fileUrl;

        // Extract the file ID based on media type
        switch (mediaType) {
            case 'photo':
                if (ctx.message.photo && ctx.message.photo.length > 0) {
                    fileId = ctx.message.photo[ctx.message.photo.length - 1].file_id;
                    console.log(`Extracted photo file_id: ${fileId}`);
                } else {
                    throw new Error('Invalid photo message structure');
                }
                break;
            case 'blank':
                if (ctx.message.blank) {
                    fileId = ctx.message.blank.file_id;
                    console.log(`Extracted video file_id: ${fileId}`);
                } else {
                    throw new Error('Invalid video message structure');
                }
                break;
            case 'animation':
                if (ctx.message.animation) {
                    fileId = ctx.message.animation.file_id;
                    console.log(`Extracted animation file_id: ${fileId}`);
                } else {
                    throw new Error('Invalid animation message structure');
                }
                break;
            case 'document':
                if (ctx.message.document) {
                    fileId = ctx.message.document.file_id;
                    console.log(`Extracted document file_id: ${fileId}`);
                } else {
                    throw new Error('Invalid document message structure');
                }
                break;
            case 'sticker':
                if (ctx.message.sticker) {
                    fileId = ctx.message.sticker.file_id;
                    console.log(`Extracted sticker file_id: ${fileId}`);
                } else {
                    throw new Error('Invalid sticker message structure');
                }
                break;
            default:
                throw new Error('Unsupported media type');
        }

        // Create a URL if possible
        if (ctx.chat.username) {
            fileUrl = `https://t.me/${ctx.chat.username}/${ctx.message.message_id}`;
        } else {
            fileUrl = fileId;
        }

        try {
            // Get the file link from Telegram
            const fileLink = await ctx.telegram.getFileLink(fileId);
            console.log(`Got file link: ${fileLink}`);
            
            // Generate a unique filename
            const fileName = `${mediaType}_${Date.now()}_${userId}.${getFileExtension(mediaType)}`;
            console.log(`Generated filename: ${fileName}`);
            
            // Save the file locally
            const savedFilePath = await saveFile(fileLink, fileName);
            console.log(`File saved locally at: ${savedFilePath}`);
            
            // Save to database
            const db = await ensureDatabaseInitialized();
            const replyData = {
                user_id: userId,
                username: username,
                trigger_word: tempReplyWord.trim(),
                type: 'media',
                media_type: mediaType,
                file_id: fileId,
                file_path: savedFilePath,
                created_at: new Date(),
                bot_id: ctx.botInfo.id // üî• add this!
              };
              await db.collection('replies').insertOne(replyData);
              
            
            console.log('Saving reply data:', JSON.stringify(replyData, null, 2));
            
            await db.collection('replies').insertOne(replyData);
            
            console.log(`Saved ${mediaType} reply to database for trigger word: ${tempReplyWord}`);
            
            // Get Arabic media type name for the response
            const mediaTypeArabic = getMediaTypeInArabic(mediaType);
            await ctx.reply(`‚úÖ ÿ™ŸÖ ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ±ÿØ ÿ®ŸÜÿ¨ÿßÿ≠!\nÿßŸÑŸÉŸÑŸÖÿ©: ${tempReplyWord}\nŸÜŸàÿπ ÿßŸÑÿ±ÿØ: ${mediaTypeArabic}`);
            
            // Reset the awaiting state
            awaitingReplyResponse = false;
            tempReplyWord = '';
            
            return true; // Successfully handled
        } catch (error) {
            console.error(`‚ùå ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ≠ŸÅÿ∏ ÿßŸÑÿ±ÿØ (${mediaType}):`, error);
            await ctx.reply('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ≠ŸÅÿ∏ ÿßŸÑÿ±ÿØ.');
            
            // Reset the awaiting state
            awaitingReplyResponse = false;
            tempReplyWord = '';
            
            return true; // We handled it, even though there was an error
        }
    } catch (error) {
        console.error(`Error in handleMediaMessage (${mediaType}):`, error);
        return false; // Error occurred, didn't handle it
    }
}

   



// Add this function to handle quiz answers
// Add this after the showQuizMenu function
async function handleTextMessage(ctx) {
    const chatId = ctx.chat.id;
    const userId = ctx.from.id;
    const userText = ctx.message.text.trim().toLowerCase();

    console.log(`Processing text message: "${userText}" from user ${userId} in chat ${chatId}`);

    // Handle state-based operations first
    if (awaitingReplyWord) {
        tempReplyWord = userText;
        await ctx.reply(`ÿ™ŸÖ ÿßÿ≥ÿ™ŸÑÿßŸÖ ÿßŸÑŸÉŸÑŸÖÿ©: "${tempReplyWord}". ÿßŸÑÿ¢ŸÜ ÿ£ÿ±ÿ≥ŸÑ ÿßŸÑÿ±ÿØ ÿßŸÑÿ∞Ÿä ÿ™ÿ±ŸäÿØ ÿ•ÿ∂ÿßŸÅÿ™Ÿá ŸÑŸáÿ∞Ÿá ÿßŸÑŸÉŸÑŸÖÿ©:`);
        awaitingReplyWord = false;
        awaitingReplyResponse = true;
        return;
    }
    
    if (awaitingReplyResponse) {
        await handleAwaitingReplyResponse(ctx);
        return;
    }
    
    if (awaitingDeleteReplyWord) {
        await handleAwaitingDeleteReplyWord(ctx);
        return;
    }
    
    if (awaitingBotName) {
        await handleAwaitingBotName(ctx);
        return;
    }

    // Check for active quiz
    if (activeQuizzes.has(chatId) && activeQuizzes.get(chatId).state === QUIZ_STATE.ACTIVE) {
        await handleQuizAnswer(ctx, chatId, userId, userText);
        return;
    }
// Check for custom bot name
const customBotName = await getCustomBotName(chatId);
if (customBotName) {
    const loweredName = customBotName.toLowerCase();
    if (userText.includes(loweredName)) {
        await ctx.reply(`ÿπŸäŸàŸÜŸá üòò: ${customBotName}`);
        return;
    }
}
console.log(`[BOT_NAME_CHECK] userText: "${userText}" | botName: "${customBotName}"`);


    // Check for user state
    if (userStates.has(userId)) {
        const userState = userStates.get(userId);
        if (userState.action === 'adding_reply') {
            if (userState.step === 'awaiting_trigger') {
                userState.triggerWord = userText; // ‚úÖ correct
                userState.step = 'awaiting_response';
                await ctx.reply('ÿßŸÑÿ¢ŸÜ ÿ£ÿ±ÿ≥ŸÑ ÿßŸÑÿ±ÿØ ÿßŸÑÿ∞Ÿä ÿ™ÿ±ŸäÿØ ÿ•ÿ∂ÿßŸÅÿ™Ÿá ŸÑŸáÿ∞Ÿá ÿßŸÑŸÉŸÑŸÖÿ©:');
                return;
            } else if (userState.step === 'awaiting_response') {
                try {
                    const db = await ensureDatabaseInitialized(userState.botId);
                    await db.collection('replies').insertOne({
                        bot_id: userState.botId,
                        trigger_word: userState.triggerWord,
                        word: userState.triggerWord, // Add this for consistency
                        type: 'text',
                        text: ctx.message.text,
                        reply_text: ctx.message.text, // Add this for backward compatibility
                        created_at: new Date(),
                        created_by: userId
                    });
                    
                    await ctx.reply(`ÿ™ŸÖ ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ±ÿØ ÿ®ŸÜÿ¨ÿßÿ≠!\nÿßŸÑŸÉŸÑŸÖÿ©: ${userState.triggerWord}\nÿßŸÑÿ±ÿØ: ${ctx.message.text}`);
                    userStates.delete(userId);
                    return;
                } catch (error) {
                    console.error('Error saving reply:', error);
                    await ctx.reply('ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ≠ŸÅÿ∏ ÿßŸÑÿ±ÿØ. ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.');
                    userStates.delete(userId);
                    return;
                }
            }
        }
    }

    // Check for automatic replies - this should work in both private and group chats
    const reply = await checkForAutomaticReply(ctx);
    if (reply) {
        console.log('Found matching reply:', reply);
        const sent = await sendReply(ctx, reply);
        if (sent) return;
    } else {
        console.log('No matching reply found for:', userText);
    }

    // If we reach here in a private chat, it means we didn't handle the message
    if (ctx.chat.type === 'private') {
        // Only send the "I don't understand" message in private chats
        // await ctx.reply('ÿπÿ∞ÿ±Ÿãÿßÿå ŸÑŸÖ ÿ£ŸÅŸáŸÖ Ÿáÿ∞Ÿá ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©. ŸáŸÑ ŸäŸÖŸÉŸÜŸÉ ÿ™Ÿàÿ∂Ÿäÿ≠ ÿ∑ŸÑÿ®ŸÉÿü');
    }
}
async function updateReplyTexts(triggerWord, texts) {
    try {
        const db = await ensureDatabaseInitialized();
        await db.collection('replies').updateOne(
            { trigger_word: triggerWord },
            { 
                $set: { 
                    reply_texts: texts,
                    cycle_index: 0
                }
            },
            { upsert: true }
        );
        console.log(`Updated reply texts for trigger word: ${triggerWord}`);
    } catch (error) {
        console.error('Error updating reply texts:', error);
    }
}

async function setReplyTypeToCycle(triggerWord) {
    try {
        const db = await ensureDatabaseInitialized();
        await db.collection('replies').updateOne(
            { trigger_word: triggerWord },
            { 
                $set: { 
                    type: 'text_cycle'
                }
            }
        );
        console.log(`Set reply type to text_cycle for trigger word: ${triggerWord}`);
    } catch (error) {
        console.error('Error setting reply type:', error);
    }
}
async function setupCyclingReply(ctx, triggerWord, texts) {
    try {
        // Update the reply texts and initialize the cycle index
        await updateReplyTexts(triggerWord, texts);

        // Set the reply type to 'text_cycle'
        await setReplyTypeToCycle(triggerWord);

        await ctx.reply(`‚úÖ ÿ™ŸÖ ÿ•ÿπÿØÿßÿØ ÿßŸÑÿ±ÿØŸàÿØ ÿßŸÑÿØŸàÿ±Ÿäÿ© ŸÑŸÑŸÉŸÑŸÖÿ©: ${triggerWord}`);
    } catch (error) {
        console.error('Error setting up cycling reply:', error);
        await ctx.reply('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ•ÿπÿØÿßÿØ ÿßŸÑÿ±ÿØŸàÿØ ÿßŸÑÿØŸàÿ±Ÿäÿ©.');
    }
}


// Add this function to check subscription status directly
async function checkSubscriptionStatus(ctx, userId) {
    try {
        const channelUsername = 'ctrlsrc'; // Your channel username without @
        
        // Try to get the user's status in the channel
        const member = await ctx.telegram.getChatMember(`@${channelUsername}`, userId);
        
        // Check if the user is a member of the channel
        const status = member.status;
        if (status === 'member' || status === 'administrator' || status === 'creator') {
            return true;
        }
        return false;
    } catch (error) {
        console.error('Error checking subscription status:', error);
        return false;
    }
}

// Replace your forceCheckSubscription function with this
async function forceCheckSubscription(ctx) {
    try {
        await ctx.answerCbQuery('ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿßÿ¥ÿ™ÿ±ÿßŸÉ...');
        
        // Instead of checking directly, we'll ask the user to join and then click a button
        await ctx.reply('ŸÑŸÑÿßÿ≥ÿ™ŸÖÿ±ÿßÿ± ŸÅŸä ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿ®Ÿàÿ™ÿå Ÿäÿ±ÿ¨Ÿâ:',
            {
                reply_markup: {
                    inline_keyboard: [
                        [{ text: '1. ÿßÿ¥ÿ™ÿ±ŸÉ ŸÅŸä ÿßŸÑŸÇŸÜÿßÿ©', url: 'https://t.me/ctrlsrc' }],
                        [{ text: '2. ÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿßÿ¥ÿ™ÿ±ÿßŸÉ', callback_data: 'confirm_subscription' }]
                    ]
                }
            }
        );
    } catch (error) {
        console.error('Error in forceCheckSubscription:', error);
        await ctx.answerCbQuery('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ŸÑÿßÿ≠ŸÇŸãÿß.', { show_alert: true });
    }
}
async function confirmSubscription(ctx) {
    try {
        // Here we assume the user has subscribed since they clicked the button
        // This is more reliable than checking membership which often fails
        
        await ctx.answerCbQuery('‚úÖ ÿ¥ŸÉÿ±ÿßŸã ŸÑÿßÿ¥ÿ™ÿ±ÿßŸÉŸÉ ŸÅŸä ÿßŸÑŸÇŸÜÿßÿ©!', { show_alert: true });
        await ctx.reply('ÿ¥ŸÉÿ±ÿßŸã ŸÑÿßÿ¥ÿ™ÿ±ÿßŸÉŸÉ! ŸäŸÖŸÉŸÜŸÉ ÿßŸÑÿ¢ŸÜ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿ®Ÿàÿ™.', {
            reply_markup: {
                inline_keyboard: [
                    [{ text: 'ÿ£ÿ∂ŸÅŸÜŸä ÿ•ŸÑŸâ ŸÖÿ¨ŸÖŸàÿπÿ™ŸÉ', url: 'https://t.me/' + ctx.botInfo.username + '?startgroup=true' }],
                    [{ text: 'ŸÇŸÜÿßÿ© ÿßŸÑÿ≥Ÿàÿ±ÿ≥', url: 'https://t.me/ctrlsrc' }]
                ]
            }
        });
        
        // You can store this user as subscribed in your database if needed
        
    } catch (error) {
        console.error('Error in confirmSubscription:', error);
        await ctx.answerCbQuery('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ŸÑÿßÿ≠ŸÇŸãÿß.', { show_alert: true });
    }
}

async function handleCorrectQuizAnswer(ctx, chatId, userId) {
    const quiz = activeQuizzes.get(chatId);
    const currentQuestion = quiz.questions[quiz.currentQuestionIndex];

    // Initialize attempts tracking for this question if it doesn't exist
    if (!quiz.attempts.has(quiz.currentQuestionIndex)) {
        quiz.attempts.set(quiz.currentQuestionIndex, new Set());
    }

    const questionAttempts = quiz.attempts.get(quiz.currentQuestionIndex);

    // Check if the user has already answered correctly
    if (!questionAttempts.has(userId)) {
        // Mark this user as having answered correctly
        questionAttempts.add(userId);

        // Update user's score
        if (!quiz.scores.has(userId)) {
            quiz.scores.set(userId, 0);
        }

        // Add points based on difficulty
        let points = 1;
        if (quiz.difficulty === 'medium') points = 2;
        if (quiz.difficulty === 'hard') points = 3;

        quiz.scores.set(userId, quiz.scores.get(userId) + points);

        // Reply to the user
        await ctx.reply(`‚úÖ ÿ•ÿ¨ÿßÿ®ÿ© ÿµÿ≠Ÿäÿ≠ÿ©! ÿ≠ÿµŸÑÿ™ ÿπŸÑŸâ ${points} ŸÜŸÇÿ∑ÿ©.`, {
            reply_to_message_id: ctx.message.message_id
        });

        // Move to the next question after a short delay
        setTimeout(async () => {
            quiz.currentQuestionIndex++;

            // Check if we've reached the end of the quiz
            if (quiz.currentQuestionIndex >= quiz.questions.length) {
                await endQuiz(ctx, chatId);
            } else {
                // Show the next question
                await askNextQuestion(chatId, ctx.telegram);
            }
        }, 2000);
    }
}
// Add this function to show a question
async function showQuestion(ctx, chatId) {
    try {
        const quiz = activeQuizzes.get(chatId);
        const currentQuestion = quiz.questions[quiz.currentQuestionIndex];
        
        // Create the question message
        const questionNumber = quiz.currentQuestionIndex + 1;
        const totalQuestions = quiz.questions.length;
        
        const message = `‚ùì ÿßŸÑÿ≥ÿ§ÿßŸÑ ${questionNumber}/${totalQuestions}:\n\n${currentQuestion.question}\n\nÿßŸÑÿÆŸäÿßÿ±ÿßÿ™:\n`;
        
        // Send the question
        await ctx.telegram.sendMessage(chatId, message);
        
        // Set a timeout for this question
        const timeout = setTimeout(async () => {
            // Check if the quiz is still active and on the same question
            if (activeQuizzes.has(chatId) && 
                activeQuizzes.get(chatId).currentQuestionIndex === quiz.currentQuestionIndex) {
                
                await ctx.telegram.sendMessage(chatId, `‚è± ÿßŸÜÿ™ŸáŸâ ÿßŸÑŸàŸÇÿ™! ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ© ŸáŸä: ${currentQuestion.correctAnswer}`);
                
                // Move to the next question
                quiz.currentQuestionIndex++;
                
                // Check if we've reached the end of the quiz
                if (quiz.currentQuestionIndex >= quiz.questions.length) {
                    await endQuiz(ctx, chatId);
                } else {
                    // Show the next question
                    await showQuestion(ctx, chatId);
                }
            }
        }, 30000); // 30 seconds per question
        
        // Store the timeout so we can clear it if needed
        quiz.timeouts.push(timeout);
    } catch (error) {
        console.error('Error showing question:', error);
    }
}    
async function startAddingCustomQuestions(ctx) {
    try {
        const chatId = ctx.chat.id;
        await ctx.reply('ŸÑÿ•ÿ∂ÿßŸÅÿ© ÿ≥ÿ§ÿßŸÑ ÿ¨ÿØŸäÿØÿå ÿ£ÿ±ÿ≥ŸÑ ŸÜÿµ ÿßŸÑÿ≥ÿ§ÿßŸÑ:');
        
        // Set the chat state to 'ADDING_QUESTION'
        chatStates.set(chatId, 'ADDING_QUESTION');
    } catch (error) {
        console.error('Error in startAddingCustomQuestions:', error);
        await ctx.reply('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ®ÿØÿ° ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ≥ÿ§ÿßŸÑ ÿßŸÑŸÖÿÆÿµÿµ.');
    }
}
// Add this function to end the quiz and show results
async function endQuiz(ctx, chatId) {
    try {
        const quiz = activeQuizzes.get(chatId);
        if (!quiz) return;
        
        // Clear all timeouts
        for (const timeout of quiz.timeouts) {
            clearTimeout(timeout);
        }
        
        // Sort scores to find the winner
        const sortedScores = [...quiz.scores.entries()]
            .sort((a, b) => b[1] - a[1])
            .slice(0, 10); // Top 10 players
        
        let resultsMessage = 'üèÅ ÿßŸÜÿ™Ÿáÿ™ ÿßŸÑŸÖÿ≥ÿßÿ®ŸÇÿ©! ÿ•ŸÑŸäŸÉŸÖ ÿßŸÑŸÜÿ™ÿßÿ¶ÿ¨:\n\n';
        
        if (sortedScores.length === 0) {
            resultsMessage += 'üòî ŸÑŸÖ Ÿäÿ¥ÿßÿ±ŸÉ ÿ£ÿ≠ÿØ ŸÅŸä Ÿáÿ∞Ÿá ÿßŸÑÿ¨ŸàŸÑÿ©.';
        } else {
            // Save scores to database and build results message
            for (let i = 0; i < sortedScores.length; i++) {
                const [userId, score] = sortedScores[i];
                let userName = 'ŸÖÿ≥ÿ™ÿÆÿØŸÖ';
                let firstName = '';
                
                try {
                    const chatMember = await ctx.telegram.getChatMember(chatId, userId);
                    userName = chatMember.user.username || 'ŸÖÿ≥ÿ™ÿÆÿØŸÖ';
                    firstName = chatMember.user.first_name || 'ŸÖÿ≥ÿ™ÿÆÿØŸÖ';
                    
                    // Save the score to the database
                    await database.saveQuizScore(chatId, userId, firstName, '', userName, score);

                    
                } catch (error) {
                    console.error('Error getting chat member or saving score:', error);
                }
                
                resultsMessage += `${i + 1}. ${firstName}: ${score} ŸÜŸÇÿ∑ÿ©\n`;
            }
        }
        
        await ctx.telegram.sendMessage(chatId, resultsMessage);
        
        // Add a button to view the global leaderboard
        await ctx.telegram.sendMessage(chatId, 'ŸÑÿπÿ±ÿ∂ ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ™ÿµÿØÿ±ŸäŸÜ ÿßŸÑÿπÿßŸÖÿ©:', {
            reply_markup: {
                inline_keyboard: [
                    [{ text: 'üèÜ ÿπÿ±ÿ∂ ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ™ÿµÿØÿ±ŸäŸÜ', callback_data: 'show_leaderboard' }]
                ]
            }
        });
        
        // Remove the quiz from active quizzes
        activeQuizzes.delete(chatId);
    } catch (error) {
        console.error('Error ending quiz:', error);
    }
}

// Define quiz questions with different difficulty levels
const difficulties = {
    easy: [
        { question: "ŸÖÿß ŸáŸà 2 + 2ÿü", answer: "1" },
        { question: "ŸÖÿß ŸáŸà ŸÑŸàŸÜ ÿßŸÑÿ≥ŸÖÿßÿ°ÿü", answer: "1" },
        { question: "ŸÉŸÖ ÿπÿØÿØ ÿ≠ÿ±ŸàŸÅ ŸÉŸÑŸÖÿ© 'ÿ®Ÿäÿ™'ÿü", answer: "1" },
        { question: "ŸÖÿß ŸáŸà ÿßÿ≥ŸÖ ÿßŸÑŸäŸàŸÖ ÿßŸÑÿ∞Ÿä Ÿäÿ£ÿ™Ÿä ÿ®ÿπÿØ ÿßŸÑÿ£ÿ±ÿ®ÿπÿßÿ°ÿü", answer: "1" },
        { question: "ŸÉŸÖ ÿπÿØÿØ ÿ£ŸäÿßŸÖ ÿßŸÑÿ£ÿ≥ÿ®Ÿàÿπÿü", answer: "1" },
        { question: "ŸÖÿß ŸáŸà ŸÑŸàŸÜ ÿßŸÑÿ¥ŸÖÿ≥ÿü", answer: "1" },
        { question: "ŸÖÿß ŸáŸà ÿπŸÉÿ≥ ŸÉŸÑŸÖÿ© 'ŸÉÿ®Ÿäÿ±'ÿü", answer: "1" },
        { question: "ŸÉŸÖ ÿπÿØÿØ ÿ£ÿ±ÿ¨ŸÑ ÿßŸÑŸÇÿ∑ÿ©ÿü", answer: "1" },
        { question: "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿáÿ± ÿßŸÑÿ∞Ÿä Ÿäÿ£ÿ™Ÿä ÿ®ÿπÿØ ŸäŸÜÿßŸäÿ±ÿü", answer: "1" },
        { question: "ŸÖÿß ŸáŸà ÿßÿ≥ŸÖ ÿßŸÑŸÉŸàŸÉÿ® ÿßŸÑÿ∞Ÿä ŸÜÿπŸäÿ¥ ÿπŸÑŸäŸáÿü", answer: "1" },
        { question: "ŸÖÿß ŸáŸà ÿßŸÑÿ≠ŸäŸàÿßŸÜ ÿßŸÑÿ∞Ÿä ŸäŸÇŸàŸÑ ŸÖŸàŸàÿü", answer: "1" },
        { question: "ŸÖÿß ÿßÿ≥ŸÖ ÿßŸÑÿ≠ŸäŸàÿßŸÜ ÿßŸÑÿ∞Ÿä Ÿäÿ≠ÿ® ÿßŸÑÿ¨ÿ≤ÿ±ÿü", answer: "1" },
        { question: "ŸÖÿß ŸáŸà ÿµŸàÿ™ ÿßŸÑŸÇÿ∑ÿ©ÿü", answer: "1" },
        { question: "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä ŸÜÿ¥ÿ±ÿ®Ÿá ŸÉŸÑ ŸäŸàŸÖÿü", answer: "1" },
        { question: "ŸÖÿß ŸáŸà ŸÑŸàŸÜ ÿßŸÑÿπÿ¥ÿ®ÿü", answer: "1" },
        { question: "ŸÉŸÖ ÿ£ÿµÿ®ÿπ ŸÅŸä ÿßŸÑŸäÿØ ÿßŸÑŸàÿßÿ≠ÿØÿ©ÿü", answer: "1" },
        { question: "ŸÖÿß ŸáŸà ÿßŸÑÿ≠ŸäŸàÿßŸÜ ÿßŸÑÿ∞Ÿä ŸäŸÜÿßŸÖ ŸÅŸä ÿßŸÑÿ¥ÿ™ÿßÿ°ÿü", answer: "1" },
        { question: "ŸÉŸÖ ÿπÿØÿØ ÿßŸÑÿπŸäŸàŸÜ ÿπŸÜÿØ ÿßŸÑÿ•ŸÜÿ≥ÿßŸÜÿü", answer: "1" },
        { question: "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä ŸÜŸÇÿ±ÿ£ ŸÖŸÜŸáÿü", answer: "1" },
        { question: "ŸÖÿß ÿßÿ≥ŸÖ ÿ£ÿØÿßÿ© ÿßŸÑŸÉÿ™ÿßÿ®ÿ©ÿü", answer: "1" },
       { question: "ŸÖÿß ŸáŸà ÿπÿØÿØ ÿ£ÿµÿßÿ®ÿπ ÿßŸÑŸÇÿØŸÖ ÿßŸÑŸàÿßÿ≠ÿØÿ©ÿü", answer: "1" },
    { question: "ŸÖÿß ŸáŸà ÿßŸÑÿ≠ŸäŸàÿßŸÜ ÿßŸÑÿ∞Ÿä ŸäÿµÿØÿ± ÿµŸàÿ™ ŸÜŸÇŸäŸÇÿü", answer: "1" },
    { question: "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä ŸÜÿ≥ÿ™ÿÆÿØŸÖŸá ŸÑŸÜÿ£ŸÉŸÑ ÿßŸÑÿ∑ÿπÿßŸÖÿü", answer: "1" },
    { question: "ŸÖÿß ŸáŸà ŸÑŸàŸÜ ÿßŸÑÿ≠ŸÑŸäÿ®ÿü", answer: "1" },
    { question: "ŸÉŸÖ ÿπÿØÿØ ÿπÿ¨ŸÑÿßÿ™ ÿßŸÑÿØÿ±ÿßÿ¨ÿ©ÿü", answer: "1" },
    { question: "ÿ£ŸäŸÜ ŸÜŸÜÿßŸÖ ŸÅŸä ÿßŸÑŸÑŸäŸÑÿü", answer: "1" },
    { question: "ŸÖÿß ÿßÿ≥ŸÖ ÿßŸÑÿ∑ÿßÿ¶ÿ± ÿßŸÑÿ∞Ÿä ŸÑÿß Ÿäÿ∑Ÿäÿ±ÿü", answer: "1" },
    { question: "ŸÖÿß ŸáŸà ÿßŸÑÿ≠ŸäŸàÿßŸÜ ÿßŸÑÿ∞Ÿä Ÿäÿ≤ÿ£ÿ±ÿü", answer: "1" },
    { question: "ŸÖÿß ÿßÿ≥ŸÖ ÿßŸÑÿ¥Ÿáÿ± ÿßŸÑÿ£ŸàŸÑ ŸÖŸÜ ÿßŸÑÿ≥ŸÜÿ©ÿü", answer: "1" },
    { question: "ŸÖÿß ŸáŸà ÿßÿ≥ŸÖ ÿßŸÑŸÅÿßŸÉŸáÿ© ÿßŸÑÿµŸÅÿ±ÿßÿ° ÿßŸÑÿ∑ŸàŸäŸÑÿ©ÿü", answer: "1" },
    { question: "ŸÖÿß ÿßÿ≥ŸÖ ÿßŸÑŸÅÿßŸÉŸáÿ© ÿßŸÑÿ≠ŸÖÿ±ÿßÿ° ÿßŸÑÿµÿ∫Ÿäÿ±ÿ© ÿßŸÑÿ™Ÿä ÿ™ŸÉŸàŸÜ ÿ≠ŸÑŸàÿ©ÿü", answer: "1" },
    { question: "ŸÉŸÖ ÿ¨ŸÜÿßÿ≠ ŸÑŸÑÿ∑ÿßÿ¶ÿ±ÿü", answer: "1" },
    { question: "ŸÖÿß ŸáŸà ÿßŸÑŸäŸàŸÖ ÿßŸÑÿ∞Ÿä Ÿäÿ£ÿ™Ÿä ÿ®ÿπÿØ ÿßŸÑÿ£ÿ≠ÿØÿü", answer: "1" },
    { question: "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä ŸÜÿ≥ŸÖÿπ ŸÖŸÜ ÿÆŸÑÿßŸÑŸáÿü", answer: "1" },
    { question: "ŸÖÿß ÿßÿ≥ŸÖ ÿßŸÑŸÖŸÉÿßŸÜ ÿßŸÑÿ∞Ÿä ŸÜÿ∞Ÿáÿ® ÿ•ŸÑŸäŸá ŸÑÿ¥ÿ±ÿßÿ° ÿßŸÑÿ∑ÿπÿßŸÖÿü", answer: "1" },
    { question: "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä ŸÜŸÑÿ®ÿ≥Ÿá ŸÅŸä ÿ£ŸÇÿØÿßŸÖŸÜÿßÿü", answer: "1" },
    { question: "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä ŸÜÿ∂ÿπŸá ÿπŸÑŸâ ÿßŸÑÿ±ÿ£ÿ≥ ŸÑŸÑÿ≠ŸÖÿßŸäÿ© ŸÖŸÜ ÿßŸÑÿ¥ŸÖÿ≥ÿü", answer: "1" },
    { question: "ŸÖÿß ŸáŸà ÿßŸÑÿ≠ŸäŸàÿßŸÜ ÿßŸÑÿ∞Ÿä ŸäÿπŸäÿ¥ ŸÅŸä ÿßŸÑŸÖÿßÿ° ŸàŸÑŸá ÿ≤ÿπÿßŸÜŸÅÿü", answer: "1" },
    { question: "ŸÖÿß ÿßÿ≥ŸÖ Ÿàÿ≥ŸäŸÑÿ© ÿßŸÑŸÜŸÇŸÑ ÿßŸÑÿ™Ÿä ÿ™ÿ∑Ÿäÿ± ŸÅŸä ÿßŸÑÿ≥ŸÖÿßÿ°ÿü", answer: "1" },
    { question: "ŸÉŸÖ ÿπÿØÿØ ÿ£ÿ±ÿ¨ŸÑ ÿßŸÑÿ•ŸÜÿ≥ÿßŸÜÿü", answer: "1" },
    { question: "ŸÖÿß ÿßÿ≥ŸÖ ÿßŸÑŸÅÿßŸÉŸáÿ© ÿßŸÑÿ™Ÿä ÿ™ŸÉŸàŸÜ ÿ®ÿ±ÿ™ŸÇÿßŸÑŸäÿ© ÿßŸÑŸÑŸàŸÜÿü", answer: "1" },
    { question: "ÿ£ŸäŸÜ ŸÜÿ∞Ÿáÿ® ÿπŸÜÿØŸÖÿß ŸÜŸÖÿ±ÿ∂ÿü", answer: "1" },
    { question: "ŸÖÿß ŸáŸà ÿßŸÑÿ≠ŸäŸàÿßŸÜ ÿßŸÑÿ∞Ÿä ŸäŸÇŸàŸÑ 'ŸÜÿπÿßŸÖÿ©'ÿü", answer: "1" },
    { question: "ŸÉŸÖ ÿπŸäŸÜ ŸÑŸÑÿ•ŸÜÿ≥ÿßŸÜÿü", answer: "1" },
    { question: "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä ŸÜÿ≥ÿ™ÿÆÿØŸÖŸá ŸÑŸÜÿ¥ÿ±ÿ® ÿßŸÑŸÖÿßÿ°ÿü", answer: "1" }
    ],
    medium: [
        { question: "ŸÖÿß ŸáŸä ÿπÿßÿµŸÖÿ© ÿ£ŸÜÿØŸàŸÜŸäÿ≥Ÿäÿßÿü", answer: "1" },
        { question: "ŸÖÿß ŸáŸà ÿßŸÑÿ∫ÿßÿ≤ ÿßŸÑÿ∞Ÿä ÿ™ŸÖÿ™ÿµŸá ÿßŸÑŸÜÿ®ÿßÿ™ÿßÿ™ ŸÖŸÜ ÿßŸÑÿ¨Ÿàÿü", answer: "1" },
        { question: "ŸÖÿß ŸáŸä ÿ£ŸÉÿ®ÿ± ŸÇÿßÿ±ÿ© ŸÅŸä ÿßŸÑÿπÿßŸÑŸÖÿü", answer: "1" },
        { question: "ŸÉŸÖ ÿπÿØÿØ ÿßŸÑÿ£ÿ≠ÿ±ŸÅ ŸÅŸä ÿßŸÑŸÑÿ∫ÿ© ÿßŸÑÿ•ŸÜÿ¨ŸÑŸäÿ≤Ÿäÿ©ÿü", answer: "1" },
        { question: "ŸÖÿß ŸáŸà ÿ£ÿ∑ŸàŸÑ ŸÜŸáÿ± ŸÅŸä ÿßŸÑÿπÿßŸÑŸÖÿü", answer: "1" },
        { question: "ŸÖÿß ŸáŸä ÿπÿßÿµŸÖÿ© ŸÅÿ±ŸÜÿ≥ÿßÿü", answer: "1" },
        { question: "ŸÖŸÜ ŸáŸà ŸÖÿÆÿ™ÿ±ÿπ ÿßŸÑŸÖÿµÿ®ÿßÿ≠ ÿßŸÑŸÉŸáÿ±ÿ®ÿßÿ¶Ÿäÿü", answer: "1" },
        { question: "ŸÖÿß ŸáŸà ÿ£ŸÉÿ®ÿ± ŸÖÿ≠Ÿäÿ∑ ŸÅŸä ÿßŸÑÿπÿßŸÑŸÖÿü", answer: "1" },
        { question: "ŸÖÿß ŸáŸä ÿßŸÑŸÑÿ∫ÿ© ÿßŸÑÿ±ÿ≥ŸÖŸäÿ© ŸÅŸä ÿßŸÑÿ®ÿ±ÿßÿ≤ŸäŸÑÿü", answer: "1" },
        { question: "ŸÉŸÖ ÿπÿØÿØ ÿßŸÑŸÇÿßÿ±ÿßÿ™ ŸÅŸä ÿßŸÑÿπÿßŸÑŸÖÿü", answer: "1" },
        { question: "ŸÖÿß ŸáŸä ÿπÿßÿµŸÖÿ© ŸÉŸÜÿØÿßÿü", answer: "1" },
        { question: "ŸÅŸä ÿ£Ÿä ŸÇÿßÿ±ÿ© ÿ™ŸÇÿπ ŸÖÿµÿ±ÿü", answer: "1" },
        { question: "ŸÖÿß ŸáŸà ÿßŸÑÿ≠ŸäŸàÿßŸÜ ÿßŸÑÿ∞Ÿä ŸäŸèÿπÿ±ŸÅ ÿ®ÿ≥ŸÅŸäŸÜÿ© ÿßŸÑÿµÿ≠ÿ±ÿßÿ°ÿü", answer: "1" },
        { question: "ŸÖÿß ÿßÿ≥ŸÖ ÿßŸÑÿ¨Ÿáÿßÿ≤ ÿßŸÑÿ∞Ÿä Ÿäÿ≥ÿ™ÿÆÿØŸÖŸá ÿßŸÑÿ∑ÿ®Ÿäÿ® ŸÑÿ≥ŸÖÿßÿπ ŸÜÿ®ÿ∂ÿßÿ™ ÿßŸÑŸÇŸÑÿ®ÿü", answer: "1" },
        { question: "ŸÖŸÜ ŸáŸà ŸÖÿÆÿ™ÿ±ÿπ ÿßŸÑŸáÿßÿ™ŸÅÿü", answer: "1" },
        { question: "ŸÖÿß ŸáŸà ÿßÿ≥ŸÖ ÿßŸÑÿπŸÖŸÑŸäÿ© ÿßŸÑÿ™Ÿä Ÿäÿ™ŸÖ ŸÅŸäŸáÿß ÿ™ÿ≠ŸàŸäŸÑ ÿßŸÑŸÖÿßÿ° ÿ•ŸÑŸâ ÿ®ÿÆÿßÿ±ÿü", answer: "1" },
        { question: "ŸÖÿß ŸáŸä ÿßŸÑŸÑÿ∫ÿ© ÿßŸÑÿ±ÿ≥ŸÖŸäÿ© ŸÅŸä ÿßŸÑŸäÿßÿ®ÿßŸÜÿü", answer: "1" },
        { question: "ŸÖÿß ŸáŸà ÿßÿ≥ŸÖ ÿßŸÑŸÉŸàŸÉÿ® ÿßŸÑÿ£ÿ≠ŸÖÿ±ÿü", answer: "1" },
        { question: "ŸÅŸä ÿ£Ÿä ŸÇÿßÿ±ÿ© ÿ™ŸÇÿπ ÿßŸÑÿ£ÿ±ÿ¨ŸÜÿ™ŸäŸÜÿü", answer: "1" },
        { question: "ŸÖÿß ÿßÿ≥ŸÖ ÿßŸÑÿ®ÿ≠ÿ± ÿßŸÑÿ∞Ÿä ŸäŸÇÿπ ÿ®ŸäŸÜ ÿßŸÑÿ≥ÿπŸàÿØŸäÿ© ŸàŸÖÿµÿ±ÿü", answer: "1" },
       { question: "ŸÖÿß ŸáŸà ÿ£ŸàŸÑ ÿ≠ÿ±ŸÅ ŸÅŸä ÿßŸÑÿ£ÿ®ÿ¨ÿØŸäÿ©ÿü", answer: "1" },
    { question: "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä ŸÜÿ£ŸÉŸÑŸá ŸàŸÜÿ≥ÿ™ÿ∑Ÿäÿπ ÿ™ŸÇÿ¥Ÿäÿ±Ÿáÿü", answer: "1" },
    { question: "ŸÖÿß ŸáŸà ÿßŸÑÿ≠ŸäŸàÿßŸÜ ÿßŸÑÿ∞Ÿä ŸäÿµÿØÿ± ÿµŸàÿ™ 'ŸÜŸáŸäŸÇ'ÿü", answer: "1" },
    { question: "ŸÖÿß ŸáŸà ÿßÿ≥ŸÖ ÿßŸÑÿ∑ÿßÿ¶ÿ± ÿßŸÑÿ∞Ÿä ŸÑÿß Ÿäÿ∑Ÿäÿ± ŸàŸäÿπŸäÿ¥ ŸÅŸä ÿßŸÑŸÇÿ∑ÿ® ÿßŸÑÿ¨ŸÜŸàÿ®Ÿäÿü", answer: "1" },
    { question: "ŸÉŸÖ ÿ•ÿµÿ®ÿπ ŸÅŸä ÿßŸÑŸÇÿØŸÖ ÿßŸÑŸàÿßÿ≠ÿØÿ©ÿü", answer: "1" },
    { question: "ŸÖÿß ŸáŸà ÿßŸÑÿ≠ŸäŸàÿßŸÜ ÿßŸÑÿ∞Ÿä Ÿäÿ®Ÿäÿ∂ÿü", answer: "1" },
    { question: "ŸÖÿß ŸáŸà ÿßŸÑÿ≠ŸäŸàÿßŸÜ ÿßŸÑÿ∞Ÿä ŸäÿπŸäÿ¥ ŸÅŸä ÿßŸÑŸÖÿßÿ° ŸàŸÑŸá ÿ≤ÿπÿßŸÜŸÅÿü", answer: "1" },
    { question: "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä ÿ™ŸÉÿ™ÿ®Ÿá ŸàŸÑÿß ÿ™ŸÇÿ±ÿ£Ÿáÿü", answer: "1" },
    { question: "ŸÖÿß ŸáŸà ÿßŸÑÿ≠ŸäŸàÿßŸÜ ÿßŸÑÿ∞Ÿä ŸäÿπŸäÿ¥ ŸÅŸä ÿßŸÑÿµÿ≠ÿ±ÿßÿ°ÿü", answer: "1" },
    { question: "ŸÖÿß ŸáŸà ŸÑŸàŸÜ ÿßŸÑÿ≠ŸÑŸäÿ®ÿü", answer: "1" },
    { question: "ŸÖÿß ÿßÿ≥ŸÖ ÿßŸÑÿÆÿ∂ÿßÿ± ÿßŸÑÿ™Ÿä ÿ™ÿ®ŸÉŸäŸÜÿß ÿπŸÜÿØ ÿ™ŸÇÿ∑ŸäÿπŸáÿßÿü", answer: "1" },
    { question: "ŸÖÿß ŸáŸà ÿßŸÑÿ≠ŸäŸàÿßŸÜ ÿßŸÑÿ∞Ÿä ŸÑŸá ÿÆÿ±ÿ∑ŸàŸÖÿü", answer: "1" },
    { question: "ŸÉŸÖ ÿπÿØÿØ ÿ£ÿ∞ŸÜŸä ÿßŸÑÿ•ŸÜÿ≥ÿßŸÜÿü", answer: "1" },
    { question: "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä ŸÜŸÉÿ™ÿ®Ÿá ŸÅŸä ÿßŸÑŸÖÿØÿ±ÿ≥ÿ©ÿü", answer: "1" },
    { question: "ŸÖÿß ÿßÿ≥ŸÖ ÿßŸÑÿ≠ÿ¥ÿ±ÿ© ÿßŸÑÿ™Ÿä ÿ™ÿµÿØÿ± ÿµŸàÿ™ÿßŸã ŸÅŸä ÿßŸÑŸÑŸäŸÑÿü", answer: "1" },
    { question: "ŸÖÿß ŸáŸà ŸÑŸàŸÜ ÿßŸÑŸÖŸàÿ≤ÿü", answer: "1" },
    { question: "ŸÅŸä ÿ£Ÿä ŸÖŸÉÿßŸÜ ŸÜÿ∂ÿπ ÿßŸÑÿ∑ÿπÿßŸÖ ŸÑŸÜÿ≠ŸÅÿ∏Ÿá ÿ®ÿßÿ±ÿØÿßŸãÿü", answer: "1" },
    { question: "ŸÖÿß ŸáŸà ÿßÿ≥ŸÖ ÿßŸÑÿ¨Ÿáÿßÿ≤ ÿßŸÑÿ∞Ÿä Ÿäÿπÿ±ÿ∂ ÿßŸÑÿµŸàÿ± ŸÅŸä ÿßŸÑÿ™ŸÑŸÅÿßÿ≤ÿü", answer: "1" },
    { question: "ŸÖÿß ŸáŸà ÿßÿ≥ŸÖ ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä ŸÜÿ∂ÿπŸá ŸÅŸä ÿ£ÿ±ÿ¨ŸÑŸÜÿß ÿπŸÜÿØ ÿßŸÑŸÖÿ¥Ÿäÿü", answer: "1" },
    { question: "ŸÖÿß ŸáŸà ÿπÿØÿØ ÿ£ÿ¨ŸÜÿ≠ÿ© ÿßŸÑÿ∑ÿßÿ¶ÿ±ÿ©ÿü", answer: "1" }
    ],
    hard: [
        { question: "ŸÖÿß ŸáŸà ÿßŸÑÿ±ŸÖÿ≤ ÿßŸÑŸÉŸäŸÖŸäÿßÿ¶Ÿä ŸÑŸÑÿ∞Ÿáÿ®ÿü", answer: "1" },
        { question: "ŸÖŸÜ ŸáŸà ŸÖÿ§ÿ≥ÿ≥ ÿπŸÑŸÖ ÿßŸÑÿ¨ÿ®ÿ±ÿü", answer: "1" },
        { question: "ŸÖÿß ŸáŸà ÿßÿ≥ŸÖ ÿ£ŸÉÿ®ÿ± ŸÉŸàŸäŸÉÿ® ŸÅŸä ÿßŸÑŸÜÿ∏ÿßŸÖ ÿßŸÑÿ¥ŸÖÿ≥Ÿäÿü", answer: "1" },
        { question: "ŸÖÿß ŸáŸä ÿ£ÿµÿ∫ÿ± ÿØŸàŸÑÿ© ŸÅŸä ÿßŸÑÿπÿßŸÑŸÖÿü", answer: "1" },
        { question: "ŸÖŸÜ ŸáŸà ŸÖÿ§ŸÑŸÅ ŸÉÿ™ÿßÿ® 'ÿßŸÑÿ£ŸÖŸäÿ±'ÿü", answer: "1" },
        { question: "ŸÖÿß ŸáŸà ÿßŸÑÿπŸÜÿµÿ± ÿßŸÑÿ£ŸÉÿ´ÿ± ŸàŸÅÿ±ÿ© ŸÅŸä ÿßŸÑŸÉŸàŸÜÿü", answer: "1" },
        { question: "ŸÖÿß ŸáŸà ÿßÿ≥ŸÖ ÿ£ÿπŸÖŸÇ ŸÜŸÇÿ∑ÿ© ŸÅŸä ÿßŸÑŸÖÿ≠Ÿäÿ∑ÿßÿ™ÿü", answer: "1" },
        { question: "ŸÖŸÜ ŸáŸà ŸÖŸÉÿ™ÿ¥ŸÅ ŸÜÿ∏ÿ±Ÿäÿ© ÿßŸÑŸÜÿ≥ÿ®Ÿäÿ©ÿü", answer: "1" },
        { question: "ŸÖÿß ŸáŸà ÿßÿ≥ŸÖ ÿ£ÿπŸÑŸâ ŸÇŸÖÿ© ÿ¨ÿ®ŸÑŸäÿ© ÿ™ÿ≠ÿ™ ÿßŸÑŸÖÿßÿ°ÿü", answer: "1" },
        { question: "ŸÖÿß ŸáŸà ÿπÿØÿØ ÿßŸÑÿπÿ∏ÿßŸÖ ŸÅŸä ÿ¨ÿ≥ŸÖ ÿßŸÑÿ•ŸÜÿ≥ÿßŸÜ ÿßŸÑÿ®ÿßŸÑÿ∫ÿü", answer: "1" },
        { question: "ŸÖÿß ÿßÿ≥ŸÖ ÿßŸÑÿπÿßŸÑŸÖ ÿßŸÑÿ∞Ÿä ÿ∑Ÿàÿ± ŸÇÿßŸÜŸàŸÜ ÿßŸÑÿ¨ÿßÿ∞ÿ®Ÿäÿ©ÿü", answer: "1" },
        { question: "ŸÖÿß ŸáŸà ÿπÿØÿØ ÿßŸÑŸÉŸàÿßŸÉÿ® ŸÅŸä ÿßŸÑŸÜÿ∏ÿßŸÖ ÿßŸÑÿ¥ŸÖÿ≥Ÿäÿü", answer: "1" },
        { question: "ŸÖÿß ŸáŸà ÿ£ÿµŸÑ ŸÉŸÑŸÖÿ© 'ŸÉŸäŸÖŸäÿßÿ°'ÿü", answer: "1" },
        { question: "ŸÖŸÜ ŸáŸà ŸÖŸÉÿ™ÿ¥ŸÅ ÿßŸÑÿØŸàÿ±ÿ© ÿßŸÑÿØŸÖŸàŸäÿ©ÿü", answer: "1" },
        { question: "ŸÖÿß ŸáŸà ÿßŸÑÿ¨Ÿáÿßÿ≤ ÿßŸÑŸÖÿ≥ÿ§ŸàŸÑ ÿπŸÜ ÿ•ŸÜÿ™ÿßÿ¨ ÿßŸÑÿ£ŸÜÿ≥ŸàŸÑŸäŸÜ ŸÅŸä ÿßŸÑÿ¨ÿ≥ŸÖÿü", answer: "1" },
        { question: "ŸÖÿß ÿßÿ≥ŸÖ ÿßŸÑŸÖÿ¨ÿ±ÿ© ÿßŸÑÿ™Ÿä ÿ™ŸÜÿ™ŸÖŸä ÿ•ŸÑŸäŸáÿß ÿßŸÑÿ£ÿ±ÿ∂ÿü", answer: "1" },
        { question: "ŸÖÿß ŸáŸà ÿßŸÑÿπŸÜÿµÿ± ÿßŸÑÿ∞Ÿä ÿ±ŸÖÿ≤Ÿá ÿßŸÑŸÉŸäŸÖŸäÿßÿ¶Ÿä Feÿü", answer: "1" },
        { question: "ŸÖŸÜ ŸÉÿ™ÿ® ŸÉÿ™ÿßÿ® 'ÿßŸÑÿ£ÿµŸÑ'ÿü", answer: "1" },
        { question: "ŸÖÿß ÿßÿ≥ŸÖ ÿßŸÑŸÜÿ∏ÿ±Ÿäÿ© ÿßŸÑÿ™Ÿä ÿ™ŸÅÿ≥ÿ± ÿ™ÿ∑Ÿàÿ± ÿßŸÑÿ£ŸÜŸàÿßÿπÿü", answer: "1" },
        { question: "ŸÖÿß ŸáŸà ÿßŸÑÿ∫ÿßÿ≤ ÿßŸÑÿ∞Ÿä Ÿäÿ™ŸÉŸàŸÜ ŸÖŸÜŸá ŸÖÿπÿ∏ŸÖ ÿßŸÑÿ∫ŸÑÿßŸÅ ÿßŸÑÿ¨ŸàŸä ŸÑŸÑÿ£ÿ±ÿ∂ÿü", answer: "1" },
        { question: "ŸÖÿß ŸáŸà ÿßÿ≥ŸÖ ÿ£ŸàŸÑ ŸÇŸÖÿ± ÿµŸÜÿßÿπŸä ÿ£Ÿèÿ∑ŸÑŸÇ ÿ•ŸÑŸâ ÿßŸÑŸÅÿ∂ÿßÿ°ÿü", answer: "1" },
    { question: "ŸÅŸä ÿ£Ÿä ÿ≥ŸÜÿ© ÿ™ÿ£ÿ≥ÿ≥ÿ™ ŸÖŸÜÿ∏ŸÖÿ© ÿßŸÑÿ£ŸÖŸÖ ÿßŸÑŸÖÿ™ÿ≠ÿØÿ©ÿü", answer: "1" },
    { question: "ŸÖÿß ÿßÿ≥ŸÖ ÿßŸÑÿπÿßŸÑŸÖ ÿßŸÑÿ∞Ÿä ÿßŸÉÿ™ÿ¥ŸÅ ÿßŸÑÿ®ŸÜÿ≥ŸÑŸäŸÜÿü", answer: "1" },
    { question: "ŸÖÿß ŸáŸà ÿßŸÑÿπŸÜÿµÿ± ÿßŸÑŸÉŸäŸÖŸäÿßÿ¶Ÿä ÿßŸÑÿ∞Ÿä ÿ±ŸÖÿ≤Ÿá Hgÿü", answer: "1" },
    { question: "ŸÖŸÜ ŸáŸà ÿ£ŸàŸÑ ŸÖŸÜ ÿØÿßÿ± ÿ≠ŸàŸÑ ÿßŸÑÿ£ÿ±ÿ∂ÿü", answer: "1" },
    { question: "ŸÖÿß ŸáŸà ÿßÿ≥ŸÖ ÿßŸÑÿ£ÿØÿßÿ© ÿßŸÑÿ™Ÿä ÿ™ŸÇŸäÿ≥ ÿ¥ÿØÿ© ÿßŸÑÿ≤ŸÑÿßÿ≤ŸÑÿü", answer: "1" },
    { question: "ŸÅŸä ÿ£Ÿä ÿØŸàŸÑÿ© ÿ™ŸÇÿπ ÿ¨ÿßŸÖÿπÿ© Ÿáÿßÿ±ŸÅÿßÿ±ÿØÿü", answer: "1" },
    { question: "ŸÖÿß ÿßÿ≥ŸÖ ÿ£ŸàŸÑ ÿ±ŸàÿßŸäÿ© ŸÅŸä ÿßŸÑÿ™ÿßÿ±ŸäÿÆÿü", answer: "1" },
    { question: "ŸÖÿß ÿßÿ≥ŸÖ ÿßŸÑŸÇŸÖÿ± ÿßŸÑÿ™ÿßÿ®ÿπ ŸÑŸÉŸàŸÉÿ® ÿßŸÑŸÖÿ±ŸäÿÆÿü", answer: "1" },
    { question: "ŸÖÿß ÿßÿ≥ŸÖ ÿ£ŸÉÿ®ÿ± ÿµÿ≠ÿ±ÿßÿ° ŸÅŸä ÿßŸÑÿπÿßŸÑŸÖÿü", answer: "1" },
    { question: "ŸÖŸÜ ŸáŸà ÿ£ŸàŸÑ ÿπÿßŸÑŸÖ Ÿàÿ∂ÿπ ÿ¨ÿØŸàŸÑÿßŸã ÿØŸàÿ±ŸäÿßŸã ŸÑŸÑÿπŸÜÿßÿµÿ±ÿü", answer: "1" },
    { question: "ŸÅŸä ÿ£Ÿä ÿ≥ŸÜÿ© Ÿáÿ®ÿ∑ ÿßŸÑÿ•ŸÜÿ≥ÿßŸÜ ÿπŸÑŸâ ÿ≥ÿ∑ÿ≠ ÿßŸÑŸÇŸÖÿ± ŸÑÿ£ŸàŸÑ ŸÖÿ±ÿ©ÿü", answer: "1" },
    { question: "ŸÖÿß ŸáŸà ÿßÿ≥ŸÖ ÿ£ÿ∂ÿÆŸÖ ÿπÿ∂ŸÑÿ© ŸÅŸä ÿ¨ÿ≥ŸÖ ÿßŸÑÿ•ŸÜÿ≥ÿßŸÜÿü", answer: "1" },
    { question: "ŸÖÿß ÿßÿ≥ŸÖ ÿßŸÑŸÖÿßÿØÿ© ÿßŸÑŸÖÿ≥ÿ§ŸàŸÑÿ© ÿπŸÜ ŸÜŸÇŸÑ ÿßŸÑÿ£ŸàŸÉÿ≥ÿ¨ŸäŸÜ ŸÅŸä ÿßŸÑÿØŸÖÿü", answer: "1" },
    { question: "ŸÖŸÜ ŸáŸà ŸÖÿ§ŸÑŸÅ ŸÉÿ™ÿßÿ® 'ÿßŸÑÿ¨ŸÖŸáŸàÿ±Ÿäÿ©'ÿü", answer: "1" },
    { question: "ŸÖÿß ÿßÿ≥ŸÖ ÿ£ŸÉÿ®ÿ± ÿ®ÿ±ŸÉÿßŸÜ ŸÜÿ¥ÿ∑ ŸÅŸä ÿßŸÑÿπÿßŸÑŸÖÿü", answer: "1" },
    { question: "ŸÖÿß ÿßÿ≥ŸÖ ÿ£ÿπŸÖŸÇ ÿ®ÿ≠Ÿäÿ±ÿ© ŸÅŸä ÿßŸÑÿπÿßŸÑŸÖÿü", answer: "1" },
    { question: "ŸÅŸä ÿ£Ÿä ŸÇÿßÿ±ÿ© ŸäŸÇÿπ ÿ¨ÿ®ŸÑ ÿ•ŸäŸÅÿ±ÿ≥ÿ™ÿü", answer: "1" },
    { question: "ŸÖŸÜ ŸáŸà ŸÖŸÉÿ™ÿ¥ŸÅ ÿßŸÑÿ•ŸÑŸÉÿ™ÿ±ŸàŸÜÿü", answer: "1" },
    { question: "ŸÖÿß ÿßÿ≥ŸÖ ÿßŸÑÿπÿßŸÑŸÖ ÿßŸÑÿ∞Ÿä Ÿàÿ∂ÿπ ŸÇŸàÿßŸÜŸäŸÜ ÿßŸÑÿ≠ÿ±ŸÉÿ© ÿßŸÑÿ´ŸÑÿßÿ´ÿ©ÿü", answer: "1" }
    ]
};


// Make sure to initialize the database before using it
async function ensureDatabaseInitialized() {
    let db = database.getDb();
    if (!db) {
        console.log('Database not initialized, connecting now...');
        db = await database.connectToMongoDB();
    }
    return db;
}


async function configureQuiz(ctx) {
    try {
        if (!(await isAdminOrOwner(ctx, ctx.from.id))) {
            return ctx.answerCbQuery('‚ùå Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ± ŸÖÿÆÿµÿµ ŸÑŸÑŸÖÿ¥ÿ±ŸÅŸäŸÜ ŸÅŸÇÿ∑.');
        }

        const chatId = ctx.chat.id;
        const settings = quizSettings.get(chatId) || { timer: 30 };

        const keyboard = {
            inline_keyboard: [
                [{ text: 'ÿßÿÆÿ™ÿ± ŸàŸÇÿ™ ÿßŸÑÿ≥ÿ§ÿßŸÑ ŸÑŸÑŸÖÿ≥ÿßÿ®ŸÇÿ©:', callback_data: 'dummy' }],
                [
                    { text: '10 ÿ´ŸàÿßŸÜ', callback_data: 'set_timer_10' },
                    { text: '20 ÿ´ÿßŸÜŸäÿ©', callback_data: 'set_timer_20' },
                    { text: '30 ÿ´ÿßŸÜŸäÿ©', callback_data: 'set_timer_30' }
                ],
                [
                    { text: '40 ÿ´ÿßŸÜŸäÿ©', callback_data: 'set_timer_40' },
                    { text: '50 ÿ´ÿßŸÜŸäÿ©', callback_data: 'set_timer_50' }
                ],
                [{ text: `ÿπÿ±ÿ∂ ÿßŸÑŸàŸÇÿ™ ÿßŸÑÿ≠ÿßŸÑŸä: ${settings.timer} ÿ´ÿßŸÜŸäÿ©`, callback_data: 'show_current_timer' }],
                [{ text: 'üîô ÿßŸÑÿπŸàÿØÿ©', callback_data: 'back_to_quiz_menu' }]
            ]
        };

        const message = `ÿßÿÆÿ™ÿ± ŸàŸÇÿ™ ÿßŸÑÿ≥ÿ§ÿßŸÑ ŸÑŸÑŸÖÿ≥ÿßÿ®ŸÇÿ©:\n\nÿßŸÑŸàŸÇÿ™ ÿßŸÑÿ≠ÿßŸÑŸä: ${settings.timer} ÿ´ÿßŸÜŸäÿ©`;

        if (ctx.callbackQuery) {
            const msg = ctx.callbackQuery.message;
            if (msg.photo) {
                // If the message has a photo, edit the caption
                await ctx.editMessageCaption(message, { reply_markup: keyboard });
            } else if (msg.text) {
                // If it's a text message, edit the text
                await ctx.editMessageText(message, { reply_markup: keyboard });
            } else {
                // If it's neither photo nor text, send a new message
                await ctx.reply(message, { reply_markup: keyboard });
            }
        } else {
            // Send a new message if it's a direct command
            await ctx.reply(message, { reply_markup: keyboard });
        }
    } catch (error) {
        console.error('Error in configureQuiz:', error);
        ctx.answerCbQuery('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ™ŸÉŸàŸäŸÜ ÿßŸÑŸÖÿ≥ÿßÿ®ŸÇÿ©.');
    }
}


// ... (rest of the existing imports and variables)
function setupActions(bot) {

    // Add this function to handle quiz configuration
    
    const userStates = new Map();
    const { Scenes, session } = require('telegraf');


    // Initialize session middleware
    bot.use(session());

    // Create a new stage for scenes
    const stage = new Scenes.Stage([/* your scenes here */]);

    // Use the stage middleware
    bot.use(stage.middleware());

 // Set up media handlers
 (bot);
    const { setupCommands, showMainMenu, showQuizMenu,chatBroadcastStates, awaitingBroadcastPhoto,updateActiveGroups, } = require('./commands');


// Photo handler

// Example usage: Call this function when a specific command is received
bot.command('setup_cycle', async (ctx) => {
    const triggerWord = '8anader';
    const texts = ["ÿπŸäŸàŸÜŸá üòò", "Ÿàÿ™ ", "ÿ®ÿπÿØŸäŸÜ üòí"];
    await setupCyclingReply(ctx, triggerWord, texts);
});
bot.on('new_chat_members', async (ctx) => {
    const newMembers = ctx.message.new_chat_members;
    if (newMembers.some(member => member.id === ctx.botInfo.id)) {
        // Bot was added to a new group
        await updateActiveGroup(ctx.chat.id, ctx.chat.title, ctx.from.id);
    }
});
// Add this new action handler
bot.action('confirm_subscription', confirmSubscription);
// Add these action handlers for timer settings
bot.action(/^set_timer_(\d+)$/, async (ctx) => {
    try {
        const chatId = ctx.chat.id;
        const newTimer = parseInt(ctx.match[1]);
        
        // Update the quiz settings for this chat
        const settings = quizSettings.get(chatId) || {};
        settings.timer = newTimer;
        quizSettings.set(chatId, settings);
        
        await ctx.answerCbQuery(`ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿ´ ŸàŸÇÿ™ ÿßŸÑÿ≥ÿ§ÿßŸÑ ÿ•ŸÑŸâ ${newTimer} ÿ´ÿßŸÜŸäÿ©`);
        
        // Refresh the configuration menu
        await configureQuiz(ctx);
    } catch (error) {
        console.error('Error updating quiz timer:', error);
        await ctx.answerCbQuery('ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™.');
    }
});
bot.action('set_custom_chat_name', async (ctx) => {
    if (await isDeveloper(ctx, ctx.from.id)) {
        await ctx.answerCbQuery();
        await ctx.reply('ÿßŸÑÿ±ÿ¨ÿßÿ° ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿßÿ≥ŸÖ ÿßŸÑŸÖÿ≠ŸÑŸä ÿßŸÑÿ¨ÿØŸäÿØ ŸÑŸÑÿ®Ÿàÿ™ ŸÅŸä Ÿáÿ∞Ÿá ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ©:');
        ctx.session.awaitingCustomChatName = true;
    } else {
        await ctx.answerCbQuery('ÿπÿ∞ÿ±Ÿãÿßÿå Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ± ŸÑŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ ŸÅŸÇÿ∑', { show_alert: true });
    }
});

bot.action('remove_custom_chat_name', async (ctx) => {
    if (await isDeveloper(ctx, ctx.from.id)) {
        await ctx.answerCbQuery();
        const chatId = ctx.chat.id;
        try {
            const db = await ensureDatabaseInitialized();
            await db.collection('bot_custom_names').deleteOne({ chat_id: chatId });
            await ctx.reply('ÿ™ŸÖ ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑÿßÿ≥ŸÖ ÿßŸÑŸÖÿ≠ŸÑŸä ŸÑŸÑÿ®Ÿàÿ™ ŸÅŸä Ÿáÿ∞Ÿá ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ©.');
        } catch (error) {
            console.error('Error removing custom chat name:', error);
            await ctx.reply('ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑÿßÿ≥ŸÖ ÿßŸÑŸÖÿ≠ŸÑŸä ŸÑŸÑÿ®Ÿàÿ™.');
        }
    } else {
        await ctx.answerCbQuery('ÿπÿ∞ÿ±Ÿãÿßÿå Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ± ŸÑŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ ŸÅŸÇÿ∑', { show_alert: true });
    }
});
bot.action('show_current_timer', async (ctx) => {
    try {
        const chatId = ctx.chat.id;
        const currentTimer = quizSettings.get(chatId)?.timer || 30; // Default to 30 seconds if not set
        await ctx.answerCbQuery(`ÿßŸÑŸàŸÇÿ™ ÿßŸÑÿ≠ÿßŸÑŸä ŸÑŸÑÿ≥ÿ§ÿßŸÑ: ${currentTimer} ÿ´ÿßŸÜŸäÿ©`, { show_alert: true });
    } catch (error) {
        console.error('Error showing current timer:', error);
        await ctx.answerCbQuery('ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿπÿ±ÿ∂ ÿßŸÑŸàŸÇÿ™ ÿßŸÑÿ≠ÿßŸÑŸä.');
    }
});
  
async function showDevPanel(ctx) {
    try {
        // Check if the message is from a private chat (DM)
        if (ctx.chat.type !== 'private') {
            await ctx.reply('‚ö†Ô∏è ŸäŸÖŸÉŸÜ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ŸÑŸàÿ≠ÿ© ÿßŸÑÿ™ÿ≠ŸÉŸÖ ŸÅŸä ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑÿÆÿßÿµÿ© ŸÅŸÇÿ∑.');
            return;
        }

        const userId = ctx.from.id;

        // Check if this is the first time the /start command is executed
        if (ownerId === null) {
            ownerId = userId; // Set the current user as the owner
            console.log(`Owner set to user ID: ${ownerId}`);
        }

        // Check if the user is a developer or the owner
        const isDev = await isDeveloper(ctx, userId);
        if (!isDev && userId !== ownerId) {
            await ctx.reply('‚õî ÿπÿ∞ÿ±Ÿãÿßÿå Ÿáÿ∞Ÿá ÿßŸÑŸÑŸàÿ≠ÿ© ŸÖÿÆÿµÿµÿ© ŸÑŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ ŸÅŸÇÿ∑.');
            return;
        }

        const message = 'ŸÖÿ±ÿ≠ÿ®ÿß ÿπÿ≤Ÿäÿ≤Ÿä ÿßŸÑŸÖÿ∑Ÿàÿ±\nÿ•ŸÑŸäŸÉ ÿßÿ≤ÿ±ÿßÿ± ÿßŸÑÿ™ÿ≠ŸÉŸÖ ÿ®ÿßŸÑÿßŸÇÿ≥ÿßŸÖ\nÿ™ÿ≥ÿ™ÿ∑Ÿäÿπ ÿßŸÑÿ™ÿ≠ŸÉŸÖ ÿ®ÿ¨ŸÖŸäÿπ ÿßŸÑÿßŸÇÿ≥ÿßŸÖ ŸÅŸÇÿ∑ ÿßÿ∂ÿ∫ÿ∑ ÿπŸÑŸâ ÿßŸÑŸÇÿ≥ŸÖ ÿßŸÑÿ∞Ÿä ÿ™ÿ±ŸäÿØŸá';
        const keyboard = {
            inline_keyboard: [
                 [{ text: 'üì≤ ÿßŸÑÿ±ÿØŸàÿØ ', callback_data: 'dev_replies' }],
                    [{ text: 'üéôÔ∏è ÿßŸÑÿ•ÿ∞ÿßÿπÿ© ', callback_data: 'dev_broadcast' }],
                    [{ text: 'üßë‚Äçüíª ÿßŸÑÿ≥Ÿàÿ±ÿ≥', callback_data: 'dev_source' }],
                    [{ text: 'üî§ ÿßÿ≥ŸÖ ÿßŸÑÿ®Ÿàÿ™ ', callback_data: 'dev_bot_name' }],
                    [{ text: 'üìä ÿßŸÑÿßÿ≠ÿµÿßÿ¶Ÿäÿßÿ™', callback_data: 'dev_statistics' }],
                    [{ text: 'üíª ÿßŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ', callback_data: 'dev_developers' }],
                    [{ text: 'üëÄ ŸÇÿ±Ÿäÿ®ÿß', callback_data: 'dev_welcome' }],
                    [{ text: ' ctrlsrc', url: 'https://t.me/ctrlsrc' }],
                    [{ text: 'üìÇ ÿπÿ±ÿ∂ ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™ ÿßŸÑŸÜÿ¥ÿ∑ÿ©', callback_data: 'show_active_groups' }],
            ]
        };

        await loadActiveGroupsFromDatabase();

        if (ctx.callbackQuery) {
            const msg = ctx.callbackQuery.message;
            if (msg.caption) {
                // If the message has a caption (e.g., it's a photo), edit the caption
                await ctx.editMessageCaption(message, { reply_markup: keyboard });
            } else {
                // If it's a text message, edit the text
                await ctx.editMessageText(message, { reply_markup: keyboard });
            }
        } else {
            // If it's a new command, just send a new message
            await ctx.reply(message, { reply_markup: keyboard });
        }
    } catch (error) {
        console.error('Error in showDevPanel:', error);
        await ctx.reply('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ŸÖÿ≠ÿßŸàŸÑÿ© ÿπÿ±ÿ∂ ŸÑŸàÿ≠ÿ© ÿßŸÑÿ™ÿ≠ŸÉŸÖ ŸÑŸÑŸÖÿ∑Ÿàÿ±.');
    }
}
    async function showStatisticsMenu(ctx) {
        const message = 'ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ - ÿßÿÆÿ™ÿ± ÿßŸÑÿ•ÿ¨ÿ±ÿßÿ° ÿßŸÑŸÖÿ∑ŸÑŸàÿ®:';
        const keyboard = {
            inline_keyboard: [
                [{ text: '‚Ä¢ ÿßŸÑÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑÿπÿßŸÖÿ© ‚Ä¢', callback_data: 'overall_stats' }],
                [{ text: '‚Ä¢ ÿßŸÑŸÖÿ¥ÿ™ÿ±ŸÉŸäŸÜ ‚Ä¢', callback_data: 'subscribers_stats' }],
                [{ text: '‚Ä¢ ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™ ‚Ä¢', callback_data: 'groups_stats' }],
                [{ text: '‚Ä¢ ÿ¨ŸÑÿ® ŸÜÿ≥ÿÆÿ© ÿßÿ≠ÿ™Ÿäÿßÿ∑Ÿäÿ© ‚Ä¢', callback_data: 'backup_data' }],
                [{ text: '‚Ä¢ ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑŸÖÿ¥ÿ™ÿ±ŸÉŸäŸÜ ‚Ä¢', callback_data: 'clean_subscribers' }],
                [{ text: '‚Ä¢ ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™ ‚Ä¢', callback_data: 'clean_groups' }],
                [{ text: 'üîô ÿ±ÿ¨Ÿàÿπ', callback_data: 'back_to_dev_panel' }]
            ]
        };
    
        await ctx.editMessageText(message, { reply_markup: keyboard });
    }
    async function showSourceMenu(ctx) {
        const message = 'ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ≥Ÿàÿ±ÿ≥ - ÿßÿÆÿ™ÿ± ÿßŸÑÿ•ÿ¨ÿ±ÿßÿ° ÿßŸÑŸÖÿ∑ŸÑŸàÿ®:';
        const keyboard = {
            inline_keyboard: [
                [{ text: '‚Ä¢ ÿ™ÿßÿ±ŸäÿÆ ÿßÿ¥ÿ™ÿ±ÿßŸÉ ÿßŸÑÿ®Ÿàÿ™ ‚Ä¢', callback_data: 'bot_subscription' }],
                [{ text: '‚Ä¢ ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ≥Ÿàÿ±ÿ≥ ‚Ä¢', callback_data: 'source_update' }],
                [{ text: '‚Ä¢ ŸÖÿ∑Ÿàÿ± ÿßŸÑÿ®Ÿàÿ™ ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿä ‚Ä¢', callback_data: 'main_bot_dev' }],
                [{ text: '‚Ä¢ ŸÖÿ®ÿ±ŸÖÿ¨ ÿßŸÑÿ≥Ÿàÿ±ÿ≥ ‚Ä¢', callback_data: 'source_programmer' }],
                [{ text: '‚Ä¢ ŸÇŸÜÿßÿ© ÿßŸÑÿ≥Ÿàÿ±ÿ≥ ‚Ä¢', callback_data: 'source_channel' }],
                [{ text: 'ctrlsrc', url: 'https://t.me/ctrlsrc' }],
                [{ text: 'üîô ÿ±ÿ¨Ÿàÿπ', callback_data: 'back_to_dev_panel' }]
            ]
        };
    
        await ctx.editMessageText(message, { reply_markup: keyboard });
    }
    async function getDevelopersList() {
        try {
            const db = await ensureDatabaseInitialized();
            const developers = await db.collection('developers').find().toArray();
            return developers;
        } catch (error) {
            console.error('Error fetching developers list:', error);
            return [];
        }
    }

    
// Function to shuffle array (for randomizing questions)
function shuffleArray(array) {
    const newArray = [...array];
    for (let i = newArray.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
    }
    return newArray;
}
    // Similarly update other functions that use pool directly
    async function createSecondaryDevelopersTable() {
        try {
            const db = await ensureDatabaseInitialized();
            // In MongoDB, collections are created automatically when documents are inserted
            console.log('secondary_developers collection ready to use');
        } catch (error) {
            console.error('Error ensuring secondary_developers collection:', error);
        }
    }
 
    
    
    
    async function populateActiveGroups(bot) {
        console.log('Populating active groups...');
        const chats = await bot.telegram.getMyCommands();
        for (const chat of chats) {
            try {
                const chatInfo = await bot.telegram.getChat(chat.chat.id);
                if (chatInfo.type === 'group' || chatInfo.type === 'supergroup') {
                    activeGroups.set(chatInfo.id, { title: chatInfo.title, id: chatInfo.id });
                    console.log(`Added group: ${chatInfo.title} (${chatInfo.id})`);
                }
            } catch (error) {
                console.error(`Error getting chat info for ${chat.chat.id}:`, error);
            }
        }
        console.log(`Populated ${activeGroups.size} active groups`);
    }
    
    // Call this function when your bot starts
    populateActiveGroups(bot);
    // Call this function when your bot starts
    createSecondaryDevelopersTable();



    async function createBotCustomNamesTable() {
        try {
            const db = await ensureDatabaseInitialized();
            // In MongoDB, collections are created automatically when documents are inserted
            console.log('bot_custom_names collection ready to use');
        } catch (error) {
            console.error('Error ensuring bot_custom_names collection:', error);
        }
    }
    // Add this function at the beginning of your file or before it's used
    async function fetchRepliesFromDatabase() {
        try {
            const db = await ensureDatabaseInitialized();
            return await db.collection('replies').find().toArray();
        } catch (error) {
            console.error('Error fetching replies:', error);
            return [];
        }
    }
// Add this function to create the groups table
async function createGroupsTable() {
    try {
        const db = await ensureDatabaseInitialized();
        // In MongoDB, collections are created automatically
        console.log('groups collection ready to use');
    } catch (error) {
        console.error('Error ensuring groups collection:', error);
    }
}
// Update this function to use MongoDB
async function markGroupAsInactive(groupId) {
    try {
        const db = await ensureDatabaseInitialized();
        await db.collection('groups').updateOne(
            { group_id: groupId },
            { $set: { is_active: false } }
        );

        activeGroups.delete(groupId);
        console.log(`Marked group ${groupId} as inactive`);
    } catch (error) {
        console.error('Error marking group as inactive:', error);
    }
}
function adminOnly(handler) {
    return async (ctx) => {
        try {
            const userId = ctx.from.id;
            const chatId = ctx.chat.id;

            // Check if the user is the owner
            if (ctx.from.username === 'Lorisiv') {
                return handler(ctx);
            }

            // Check subscription
            const { isSubscribed, statusChanged } = await isSubscribed(ctx, userId);
            if (!isSubscribed) {
                return ctx.reply('Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿßÿ¥ÿ™ÿ±ÿßŸÉ ÿ®ŸÇŸÜÿßÿ© ÿßŸÑÿ®Ÿàÿ™ ŸÑŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ', {
                    reply_markup: {
                        inline_keyboard: [
                            [{ text: 'ÿßÿ¥ÿ™ÿ±ŸÉ ÿßŸÑÿ¢ŸÜ', url: 'https://t.me/ctrlsrc' }],
                            [{ text: 'ÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿßÿ¥ÿ™ÿ±ÿßŸÉ', callback_data: 'check_subscription' }]
                        ]
                    }
                });
            }

            if (statusChanged) {
                // User just subscribed, show the new prompt
                await ctx.reply('ÿ¥ŸÉÿ±ÿßŸã ŸÑÿßÿ¥ÿ™ÿ±ÿßŸÉŸÉ! ŸäŸÖŸÉŸÜŸÉ ÿßŸÑÿ¢ŸÜ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿ®Ÿàÿ™.', {
                    reply_markup: {
                        inline_keyboard: [
                            [{ text: 'ÿ£ÿ∂ŸÅŸÜŸä ÿ•ŸÑŸâ ŸÖÿ¨ŸÖŸàÿπÿ™ŸÉ', url: `https://t.me/${ctx.botInfo.username}?startgroup=true` }],
                            [{ text: 'ŸÇŸÜÿßÿ© ÿßŸÑÿ≥Ÿàÿ±ÿ≥', url: 'https://t.me/ctrlsrc' }]
                        ]
                    }
                });
            }

            // Check if the user is an admin or owner
            const isAdmin = await isAdminOrOwner(ctx, userId);
            if (isAdmin) {
                return handler(ctx);
            } else {
                return ctx.reply('‚ùå Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ± ŸÖÿÆÿµÿµ ŸÑŸÑŸÖÿ¥ÿ±ŸÅŸäŸÜ ŸÅŸÇÿ∑.');
            }
        } catch (error) {
            console.error('Error in adminOnly wrapper:', error);
            return ctx.reply('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿµŸÑÿßÿ≠Ÿäÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ŸÑÿßÿ≠ŸÇŸãÿß.');
        }
    };
}
 // Update this function to use MongoDB
 async function getOverallStats() {
    try {
        const db = await ensureDatabaseInitialized();
        const subscribers = await db.collection('users').countDocuments({ is_active: true });
        const groups = await db.collection('groups').countDocuments({ is_active: true });
        const total = subscribers + groups;

        return { subscribers, groups, total };
    } catch (error) {
        console.error('Error getting overall stats:', error);
        return { subscribers: 0, groups: 0, total: 0 };
    }
}

async function getSubscribersCount() {
    try {
        const db = await ensureDatabaseInitialized();
        return await db.collection('users').countDocuments({ is_active: true });
    } catch (error) {
        console.error('Error getting subscribers count:', error);
        return 0;
    }
}

async function getGroupsCount() {
    try {
        const db = await ensureDatabaseInitialized();
        return await db.collection('groups').countDocuments({ is_active: true });
    } catch (error) {
        console.error('Error getting groups count:', error);
        return 0;
    }
}

async function generateBackup() {
    try {
        const db = await ensureDatabaseInitialized();
        const users = await db.collection('users').find().toArray();
        const groups = await db.collection('groups').find().toArray();
        const developers = await db.collection('developers').find().toArray();
        const replies = await db.collection('replies').find().toArray();

        return {
            botId: bot.botInfo.id,
            botName: bot.botInfo.username,
            users,
            groups,
            developers,
            replies,
            timestamp: new Date().toISOString()
        };
    } catch (error) {
        console.error('Error generating backup:', error);
        return null;
    }
}

async function cleanSubscribers() {
    try {
        const db = await ensureDatabaseInitialized();
        const thirtyDaysAgo = new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
        
        const result = await db.collection('users').updateMany(
            { last_interaction: { $lt: thirtyDaysAgo } },
            { $set: { is_active: false } }
        );
        
        return result.modifiedCount;
    } catch (error) {
        console.error('Error cleaning subscribers:', error);
        return 0;
    }
}
// Add this function to fix null trigger words in the database
async function fixNullTriggerWords() {
    try {
        const db = await ensureDatabaseInitialized();
        
        // Find all replies with null trigger_word
        const nullTriggerReplies = await db.collection('replies').find({ 
            trigger_word: null 
        }).toArray();
        
        console.log(`Found ${nullTriggerReplies.length} replies with null trigger_word`);
        
        // Process each reply with null trigger_word
        for (const reply of nullTriggerReplies) {
            try {
                // Generate a unique trigger word based on timestamp
                const uniqueTrigger = `auto_generated_${Date.now()}_${Math.floor(Math.random() * 1000)}`;
                
                // Update the reply with the unique trigger word
                await db.collection('replies').updateOne(
                    { _id: reply._id },
                    { $set: { trigger_word: uniqueTrigger } }
                );
                
                console.log(`Updated reply ${reply._id} with trigger word: ${uniqueTrigger}`);
            } catch (updateError) {
                console.error(`Error updating reply ${reply._id}:`, updateError);
            }
        }
        
        // Check if there are any remaining null trigger words
        const remainingNullTriggers = await db.collection('replies').countDocuments({ 
            trigger_word: null 
        });
        
        console.log(`Remaining replies with null trigger_word: ${remainingNullTriggers}`);
        
        return {
            processed: nullTriggerReplies.length,
            remaining: remainingNullTriggers
        };
    } catch (error) {
        console.error('Error fixing null trigger words:', error);
        return {
            processed: 0,
            remaining: -1,
            error: error.message
        };
    }
}


// Helper function to get file extension based on media type
function getFileExtension(mediaType) {
    switch (mediaType) {
        case 'photo':
            return 'jpg';
        case 'wzes':
            return 'mp4';
        case 'animation':
            return 'mp4';
        case 'document':
            return 'file';
        case 'sticker':
            return 'webp';
        default:
            return 'bin';
    }
}

// Add this to your initialization code
async function initializeDatabase() {
    try {
        // Connect to MongoDB
        await database.connectToMongoDB();
        
        // Ensure unique index on trigger_word
        await ensureUniqueIndexOnTriggerWord();
        
        // Fix any existing null trigger words
        await fixNullTriggerWords();
        
        console.log('Database initialization completed successfully');
    } catch (error) {
        console.error('Error during database initialization:', error);
    }
}

// Call the initialization function
initializeDatabase();
// Add this function to create a unique index on trigger_word if it doesn't exist
async function ensureUniqueIndexOnTriggerWord() {
    try {
        const db = await ensureDatabaseInitialized();
        
        // Check if the index already exists
        const indexes = await db.collection('replies').indexes();
        const hasUniqueIndex = indexes.some(index => 
            index.key && index.key.trigger_word === 1 && index.unique === true
        );
        
        if (!hasUniqueIndex) {
            // Create a unique index on trigger_word, but allow null values
            await db.collection('replies').createIndex(
                { trigger_word: 1 }, 
                { 
                    unique: true,
                    partialFilterExpression: { trigger_word: { $type: "string" } }
                }
            );
            console.log('Created unique index on trigger_word field (excluding null values)');
        } else {
            console.log('Unique index on trigger_word already exists');
        }
        
        return true;
    } catch (error) {
        console.error('Error ensuring unique index on trigger_word:', error);
        return false;
    }
}
async function cleanGroups() {
    try {
        const db = await ensureDatabaseInitialized();
        const thirtyDaysAgo = new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
        
        const result = await db.collection('groups').updateMany(
            { last_activity: { $lt: thirtyDaysAgo } },
            { $set: { is_active: false } }
        );
        
        return result.modifiedCount;
    } catch (error) {
        console.error('Error cleaning groups:', error);
        return 0;
    }
}
// Update this function to use MongoDB
async function updateLastInteraction(userId, username, firstName, lastName) {
    try {
        await database.addUser(userId, username, firstName, lastName);
    } catch (error) {
        console.error('Error updating last interaction for user:', error);
    }
}



async function handleCustomQuestionInput(ctx) {
    const chatId = ctx.chat.id;
    const state = chatStates.get(chatId);
    
    if (!ctx.session) {
        ctx.session = {};
    }
    
    if (state === 'ADDING_QUESTION') {
        // Save the question and ask for the answer
        ctx.session.tempQuestion = ctx.message.text;
        await ctx.reply('ÿ™ŸÖ ÿßÿ≥ÿ™ŸÑÿßŸÖ ÿßŸÑÿ≥ÿ§ÿßŸÑ. ÿßŸÑÿ¢ŸÜ ÿ£ÿ±ÿ≥ŸÑ ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ©:');
        chatStates.set(chatId, 'ADDING_ANSWER');
    } else if (state === 'ADDING_ANSWER') {
        // Save the answer and add the question to the database
        const question = ctx.session.tempQuestion;
        const answer = ctx.message.text;
        
        try {
            await saveCustomQuestion(chatId, question, answer);
            await ctx.reply('‚úÖ ÿ™ŸÖ ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ≥ÿ§ÿßŸÑ ŸàÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© ÿ®ŸÜÿ¨ÿßÿ≠.');
            
            // Ask if they want to add another question
            await ctx.reply('ŸáŸÑ ÿ™ÿ±ŸäÿØ ÿ•ÿ∂ÿßŸÅÿ© ÿ≥ÿ§ÿßŸÑ ÿ¢ÿÆÿ±ÿü', {
                reply_markup: {
                    inline_keyboard: [
                        [{ text: 'ŸÜÿπŸÖ', callback_data: 'add_another_question' }],
                        [{ text: 'ŸÑÿßÿå ÿßŸÑÿπŸàÿØÿ© ŸÑŸÑŸÇÿßÿ¶ŸÖÿ©', callback_data: 'back_to_quiz_menu' }]
                    ]
                }
            });
        } catch (error) {
            console.error('Error adding custom question:', error);
            await ctx.reply('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ≥ÿ§ÿßŸÑ ŸàÿßŸÑÿ•ÿ¨ÿßÿ®ÿ©.');
        }
        
        // Clear the temporary storage
        delete ctx.session.tempQuestion;
    }
}

// Add this function to save the custom question to the database
async function saveCustomQuestion(chatId, question, answer) {
    try {
        const db = await ensureDatabaseInitialized();
        await db.collection('custom_questions').insertOne({
            chatId: chatId,
            question: question,
            answer: answer,
            createdAt: new Date()
        });
    } catch (error) {
        console.error('Error saving custom question:', error);
        throw error;
    }
}
// Handle the reply response
async function handleAwaitingReplyResponse(ctx) {
    if (!awaitingReplyResponse) return false;

    try {
        const userState = userStates.get(ctx.from.id);
        const botId = userState?.botId;

        if (!botId) {
            await ctx.reply('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ÿ≠ÿØŸäÿØ ŸÖÿπÿ±ŸÅ ÿßŸÑÿ®Ÿàÿ™. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.');
            awaitingReplyResponse = false;
            return true;
        }

        // Ensure tempReplyWord is defined
        if (!tempReplyWord) {
            await ctx.reply('‚ùå ÿßŸÑŸÉŸÑŸÖÿ© ÿßŸÑŸÖŸÅÿ™ÿßÿ≠Ÿäÿ© ÿ∫Ÿäÿ± ŸÖÿ≠ÿØÿØÿ©. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.');
            awaitingReplyResponse = false;
            return true;
        }

        // Continue with the reply saving process
        let mediaType = 'text';
        let replyText = null;
        let mediaUrl = null;
        let fileId = null;

        if (ctx.message.text) {
            mediaType = 'text';
            replyText = ctx.message.text.trim();
        } else {
            await ctx.reply('‚ùå ŸÜŸàÿπ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿ∫Ÿäÿ± ŸÖÿØÿπŸàŸÖ. Ÿäÿ±ÿ¨Ÿâ ÿ•ÿ±ÿ≥ÿßŸÑ ŸÜÿµ.');
            awaitingReplyResponse = false;
            return true;
        }

        const db = await ensureDatabaseInitialized();

        // Check if trigger word already exists
        const existingReply = await db.collection('replies').findOne({ 
            trigger_word: tempReplyWord,
            bot_id: botId
        });
        
        if (existingReply) {
            await ctx.reply(`‚ùå ÿßŸÑŸÉŸÑŸÖÿ© ÿßŸÑŸÖŸÅÿ™ÿßÿ≠Ÿäÿ© "${tempReplyWord}" ŸÖŸàÿ¨ŸàÿØÿ© ÿ®ÿßŸÑŸÅÿπŸÑ. Ÿäÿ±ÿ¨Ÿâ ÿßÿÆÿ™Ÿäÿßÿ± ŸÉŸÑŸÖÿ© ÿ£ÿÆÿ±Ÿâ.`);
            awaitingReplyResponse = false;
            return true;
        }

        // Add the reply to the database
        await db.collection('replies').insertOne({
            trigger_word: tempReplyWord,
            type: mediaType,
            text: replyText,
            media_url: mediaUrl,
            file_id: fileId,
            created_at: new Date(),
            created_by: ctx.from.id,
            bot_id: botId
        });

        await ctx.reply(`‚úÖ ÿ™ŸÖ ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ±ÿØ ŸÑŸÑŸÉŸÑŸÖÿ© "${tempReplyWord}" ÿ®ŸÜÿ¨ÿßÿ≠.`);

        // Reset state
        tempReplyWord = '';
        awaitingReplyResponse = false;
        return true;
    } catch (error) {
        console.error('Error adding reply:', error);
        await ctx.reply('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ±ÿØ. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ŸÑÿßÿ≠ŸÇŸãÿß.');
        awaitingReplyResponse = false;
        return true;
    }
}
// Add these action handlers
bot.action('add_another_question', async (ctx) => {
    await ctx.answerCbQuery();
    await ctx.reply('ŸÑÿ•ÿ∂ÿßŸÅÿ© ÿ≥ÿ§ÿßŸÑ ÿ¨ÿØŸäÿØÿå ÿ£ÿ±ÿ≥ŸÑ ŸÜÿµ ÿßŸÑÿ≥ÿ§ÿßŸÑ:');
    chatStates.set(ctx.chat.id, 'ADDING_QUESTION');
});

bot.action('back_to_quiz_menu', async (ctx) => {
    await ctx.answerCbQuery();
    chatStates.delete(ctx.chat.id);
    await showQuizMenu(ctx);
});


async function setUserAsVIP(userId) {
    try {
        const db = await ensureDatabaseInitialized();
        const result = await db.collection('users').updateOne(
            { user_id: userId },
            { $set: { role: 'vip', is_vip: true } },
            { upsert: true }
        );
        console.log(`Set user ${userId} as VIP. Result:`, result);
        return result.modifiedCount > 0 || result.upsertedCount > 0;
    } catch (error) {
        console.error('Error setting user as VIP:', error);
        return false;
    }
}
// Add this function to ask the next question
async function askNextQuestion(chatId, telegram) {
    const quiz = activeQuizzes.get(chatId);
    if (!quiz || quiz.state !== QUIZ_STATE.ACTIVE) return;
    
    const currentQuestion = quiz.questions[quiz.currentQuestionIndex];
    const questionNumber = quiz.currentQuestionIndex + 1;
    const totalQuestions = quiz.questions.length;
    
    // Get the timer setting for this chat, default to 30 seconds if not set
    const timer = quizSettings.get(chatId)?.timer || 30;
    
    await telegram.sendMessage(
        chatId,
        `ÿßŸÑÿ≥ÿ§ÿßŸÑ ${questionNumber}/${totalQuestions}:\n\n${currentQuestion.question}\n\n‚è±Ô∏è ŸÑÿØŸäŸÉ ${timer} ÿ´ÿßŸÜŸäÿ© ŸÑŸÑÿ•ÿ¨ÿßÿ®ÿ©!`
    );
    
    // Clear any existing timeouts for this quiz
    while (quiz.timeouts.length) {
        clearTimeout(quiz.timeouts.pop());
    }
    
    // Set a timeout to move to the next question if no one answers correctly
    const timeout = setTimeout(async () => {
        if (activeQuizzes.has(chatId) && 
            activeQuizzes.get(chatId).state === QUIZ_STATE.ACTIVE &&
            activeQuizzes.get(chatId).currentQuestionIndex === quiz.currentQuestionIndex) {
            
            await telegram.sendMessage(
                chatId,
                `‚è±Ô∏è ÿßŸÜÿ™ŸáŸâ ÿßŸÑŸàŸÇÿ™! ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ© ŸáŸä: ${currentQuestion.answer}`
            );
            
            // Move to the next question
            quiz.currentQuestionIndex++;
            
            // Check if we've reached the end of the quiz
            if (quiz.currentQuestionIndex >= quiz.questions.length) {
                await endQuiz({ telegram, chat: { id: chatId } }, chatId);
            } else {
                // Ask the next question
                await askNextQuestion(chatId, telegram);
            }
        }
    }, timer * 1000); // Convert seconds to milliseconds
    
    // Store the timeout so we can clear it if someone answers correctly
    quiz.timeouts.push(timeout);
}
// Call this function when initializing the database
createGroupsTable();
   
    async function hasRequiredPermissions(ctx, userId) {
        const isAdmin = await isAdminOrOwner(ctx, userId);
        const isSecDev = await isSecondaryDeveloper(ctx, userId);
        return isAdmin || isSecDev;
    }
    async function loadActiveGroupsFromDatabase() {
        try {
            const db = await ensureDatabaseInitialized();
            
            const groups = await db.collection('groups').find({ is_active: true }).toArray();
            
            activeGroups.clear();
            for (const group of groups) {
                activeGroups.set(group.group_id, { title: group.title, id: group.group_id });
            }
            console.log(`Loaded ${activeGroups.size} active groups from database`);
        } catch (error) {
            console.error('Error loading active groups from database:', error);
        }
    }
// Add this function to handle the list replies button
async function listAllReplies(ctx, botId) {
    try {
        const replies = await getAllReplies(botId);
        
        if (!replies || replies.length === 0) {
            await ctx.editMessageText('ÿßŸÑÿ±ÿØŸàÿØ ÿßŸÑÿπÿßŸÖÿ©:\n\nŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ±ÿØŸàÿØ ÿπÿßŸÖÿ© ÿ≠ÿßŸÑŸäÿßŸã', {
                reply_markup: {
                    inline_keyboard: [
                        [{ text: 'ÿ±ÿ¨Ÿàÿπ', callback_data: 'dev_replies' }]
                    ]
                }
            });
            return;
        }
        
        // Format the replies list
        let message = 'ÿßŸÑÿ±ÿØŸàÿØ ÿßŸÑÿπÿßŸÖÿ©:\n\n';
        replies.forEach((reply, index) => {
            const triggerWord = reply.trigger_word || reply.word || 'ÿ∫Ÿäÿ± ŸÖÿπÿ±ŸàŸÅ';
            let responseText = reply.reply_text || reply.text || '[ŸÖÿ≠ÿ™ŸàŸâ Ÿàÿ≥ÿßÿ¶ÿ∑]';
            
            // Truncate long responses
            if (responseText.length > 30) {
                responseText = responseText.substring(0, 27) + '...';
            }
            
            message += `${index + 1}. "${triggerWord}" ‚û°Ô∏è "${responseText}"\n`;
        });
        
        // Add pagination if the list is too long
        if (message.length > 4000) {
            message = message.substring(0, 3900) + '\n\n... ŸàÿßŸÑŸÖÿ≤ŸäÿØ ŸÖŸÜ ÿßŸÑÿ±ÿØŸàÿØ';
        }
        
        await ctx.editMessageText(message, {
            reply_markup: {
                inline_keyboard: [
                    [{ text: 'ÿ•ÿ∂ÿßŸÅÿ© ÿ±ÿØ', callback_data: 'add_reply' }, { text: 'ÿ≠ÿ∞ŸÅ ÿ±ÿØ', callback_data: 'delete_reply' }],
                    [{ text: 'ÿ±ÿ¨Ÿàÿπ', callback_data: 'dev_replies' }]
                ]
            }
        });
    } catch (error) {
        console.error('Error listing replies:', error);
        await ctx.answerCbQuery('ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ŸÖÿ≠ÿßŸàŸÑÿ© ÿπÿ±ÿ∂ ÿßŸÑÿ±ÿØŸàÿØ');
        await ctx.editMessageText('ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ŸÖÿ≠ÿßŸàŸÑÿ© ÿπÿ±ÿ∂ ÿßŸÑÿ±ÿØŸàÿØ. ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.', {
            reply_markup: {
                inline_keyboard: [
                    [{ text: 'ÿ±ÿ¨Ÿàÿπ', callback_data: 'dev_replies' }]
                ]
            }
        });
    }
}
// Add this action handler for adding a new reply
bot.action('add_reply', async (ctx) => {
    const userId = ctx.from.id;
    const botId = ctx.botInfo.id;

    pendingReplies.set(userId, { step: 'awaiting_trigger', botId });
    await ctx.reply('ÿ£ÿ±ÿ≥ŸÑ ÿßŸÑŸÉŸÑŸÖÿ© ÿßŸÑÿ™Ÿä ÿ™ÿ±ŸäÿØ ÿ•ÿ∂ÿßŸÅÿ© ÿ±ÿØ ŸÑŸáÿß:');
});

// Add this to your callback query handler
// Add this to your callback query handler
bot.action('list_replies', async (ctx) => {
    const botId = ctx.botInfo.id;
    await listAllReplies(ctx, botId);
});
// Update the dev_replies handler to include the list option
bot.action('dev_replies', async (ctx) => {
    try {
        await ctx.editMessageText('ŸÇÿ≥ŸÖ ÿßŸÑÿ±ÿØŸàÿØ ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿäÿ©: Ÿäÿ±ÿ¨Ÿâ ÿπÿØŸÖ ÿßÿ∂ÿßŸÅÿ© ŸÉŸÑŸÖÿ© ŸÉÿßÿ®ÿ™ŸÑ ŸÑŸÑÿ∫ÿ© ÿßŸÑÿßŸÜÿ¨ŸÑŸäÿ≤Ÿäÿ© üßê', {
            reply_markup: {
                inline_keyboard: [
                    [{ text: 'ÿπÿ±ÿ∂ ÿßŸÑÿ±ÿØŸàÿØ', callback_data: 'list_replies' }],
                    [{ text: 'ÿ•ÿ∂ÿßŸÅÿ© ÿ±ÿØ', callback_data: 'add_reply' }],
                    [{ text: 'ÿ≠ÿ∞ŸÅ ÿ±ÿØ', callback_data: 'delete_reply' }],
                    [{ text: 'ÿ±ÿ¨Ÿàÿπ', callback_data: 'back_to_dev_panel' }]
                ]
            }
        });
    } catch (error) {
        console.error('Error in dev_replies handler:', error);
        await ctx.answerCbQuery('ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ™ÿ≠ŸÖŸäŸÑ ŸÇÿ≥ŸÖ ÿßŸÑÿ±ÿØŸàÿØ');
    }
});
async function getAllReplies(botId) {
    try {
        const db = await ensureDatabaseInitialized();
        return await db.collection('replies').find({ bot_id: botId }).toArray();
    } catch (error) {
        console.error('Error fetching all replies:', error);
        return [];
    }
}
    function showRepliesMenu(ctx) {
        const botId = ctx.botInfo.id;
        const message = 'ŸÇÿ≥ŸÖ ÿßŸÑÿ±ÿØŸàÿØ - ÿßÿÆÿ™ÿ± ÿßŸÑÿ•ÿ¨ÿ±ÿßÿ° ÿßŸÑŸÖÿ∑ŸÑŸàÿ®:';
        const keyboard = {
            inline_keyboard: [
                [{ text: '‚Ä¢ ÿßÿ∂ŸÅ ÿ±ÿØ ÿπÿßŸÖ ‚Ä¢', callback_data: `add_general_reply:${botId}` }],
                [{ text: '‚Ä¢ ÿ≠ÿ∞ŸÅ ÿ±ÿØ ÿπÿßŸÖ ‚Ä¢', callback_data: `delete_general_reply:${botId}` }],
                [{ text: '‚Ä¢ ÿπÿ±ÿ∂ ÿßŸÑÿ±ÿØŸàÿØ ÿßŸÑÿπÿßŸÖÿ© ‚Ä¢', callback_data: `list_general_replies:${botId}` }],
                [{ text: '‚ùå ÿ≠ÿ∞ŸÅ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ±ÿØŸàÿØ', callback_data: `delete_all_replies:${botId}` }],
                [{ text: 'üîô ÿ±ÿ¨Ÿàÿπ', callback_data: 'back_to_dev_panel' }]
            ]
        };
    
        ctx.editMessageText(message, { reply_markup: keyboard });
    }
// Add this callback handler for returning to the main menu
bot.action('back_to_main', async (ctx) => {
    try {
        await ctx.answerCbQuery();

        // Check if the user is an admin, owner, or secondary developer
        const isAdmin = await isAdminOrOwner(ctx, ctx.from.id);
        const isSecDev = await isSecondaryDeveloper(ctx, ctx.from.id);
        const isVIPUser = await isVIP(ctx, ctx.from.id);

        // New check for secondary developer in the database
        const db = await ensureDatabaseInitialized();
        const secDevInDb = await db.collection('secondary_developers').findOne({ user_id: ctx.from.id });

        if (!isAdmin && !isSecDev && !isVIPUser && !secDevInDb) {
            return ctx.answerCbQuery('‚ùå Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ± ŸÖÿÆÿµÿµ ŸÑŸÑŸÖÿ¥ÿ±ŸÅŸäŸÜ ŸàÿßŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ ÿßŸÑÿ´ÿßŸÜŸàŸäŸäŸÜ ŸàÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ ÿßŸÑŸÖŸÖŸäÿ≤ŸäŸÜ ŸÅŸÇÿ∑.', { show_alert: true });
        }

        // Get the original photo URL
        const photoUrl = 'https://i.postimg.cc/R0jjs1YY/bot.jpg';
        
        // Edit the message to show the main menu again
        await ctx.editMessageMedia(
            {
                type: 'photo',
                media: photoUrl,
                caption: 'ü§ñ ŸÖÿ±ÿ≠ÿ®Ÿãÿß! ÿ£ŸÜÿß ÿ®Ÿàÿ™ ÿßŸÑÿ≠ŸÖÿßŸäÿ© ŸàÿßŸÑŸÖÿ≥ÿßÿ®ŸÇÿßÿ™ ÿßŸäÿ∂ÿß . ÿßÿÆÿ™ÿ± ÿÆŸäÿßÿ±Ÿãÿß:'


            },
            {
                reply_markup: {
                    inline_keyboard: [
                        [{ text: 'test holder 1', url: 'https://t.me/ctrlsrc' }],
                        [{ text: 'üìú ÿπÿ±ÿ∂ ÿßŸÑÿ£ŸàÿßŸÖÿ±', callback_data: 'show_commands' }],
                        
                        [{ text: 'üéÆ ÿ®Ÿàÿ™ ÿßŸÑŸÖÿ≥ÿßÿ®ŸÇÿßÿ™', callback_data: 'quiz_bot' }],
                        [{ text: 'ctrlsrc', url: 'https://t.me/ctrlsrc' }]
                    ]
                }
            }
        );
    } catch (error) {
        console.error('Error returning to main menu:', error);
        await ctx.reply('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿßŸÑÿπŸàÿØÿ© ŸÑŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©.');
    }
});
 
// Add this callback handler for the quiz_bot button
// Update the quiz-related commands to check for VIP status
bot.action('quiz_bot', async (ctx) => {
    try {
        const userId = ctx.from.id;
        const hasPermissions = await hasRequiredPermissions(ctx, userId);
        const isUserVIP = await isVIP(ctx, userId);
        
        console.log(`User ${userId} permissions check:`, { hasPermissions, isUserVIP });

        if (!hasPermissions && !isUserVIP) {
            console.log(`User ${userId} denied access to quiz_bot`);
            return ctx.answerCbQuery('‚ùå Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ± ŸÖÿÆÿµÿµ ŸÑŸÑŸÖÿ¥ÿ±ŸÅŸäŸÜ ŸàÿßŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ ŸàÿßŸÑŸÖŸÖŸäÿ≤ŸäŸÜ ŸÅŸÇÿ∑.', { show_alert: true });
        }

        await ctx.answerCbQuery();
        await showQuizMenu(ctx);
    } catch (error) {
        console.error('Error handling quiz_bot action:', error);
        await ctx.reply('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ŸÅÿ™ÿ≠ ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ≥ÿßÿ®ŸÇÿßÿ™.');
    }
});

bot.action('show_commands', async (ctx) => {
    try {
        if (!await hasRequiredPermissions(ctx, ctx.from.id)) {
            return ctx.answerCbQuery('‚ùå Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ± ŸÖÿÆÿµÿµ ŸÑŸÑŸÖÿ¥ÿ±ŸÅŸäŸÜ ŸàÿßŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ ÿßŸÑÿ´ÿßŸÜŸàŸäŸäŸÜ ŸÅŸÇÿ∑.', { show_alert: true });
        }

        // First part of the message
        const commandsPart1 = 
            'üìú *ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ£ŸàÿßŸÖÿ±:*\n\n' +
            'üîπ */ ŸÖÿπÿ±ŸÅŸä , ÿ±ÿ™ÿ®ÿ™Ÿä* ‚Äì  ÿ∏ŸáŸàÿ± ÿ±ÿ™ÿ®ÿ™ŸÉ - ÿ∏ŸáŸàÿ± ÿßŸÑÿßŸäÿØŸä Ÿà ŸÖÿπÿ±ŸÅŸÉ\n' +
            'üîπ */ÿ±ŸÅÿπ ÿßŸÖŸÜ ŸÖÿ≥ÿßÿ®ŸÇÿßÿ™* ‚Äì ÿ±ŸÅÿπ ÿßÿØŸÖŸÜ ŸÖÿ≥ÿßÿ®ŸÇÿßÿ™\n' +
            'üîπ */ÿ™ŸÜÿ≤ŸäŸÑ ÿßŸÖŸÜ ŸÖÿ≥ÿßÿ®ŸÇÿßÿ™* ‚Äì ÿ™ŸÜÿ≤ŸäŸÑ ÿßÿØŸÖŸÜ ŸÖÿ≥ÿßÿ®ŸÇÿßÿ™\n' +
            'üîπ */ÿ±ŸÅÿπ ŸÖŸÖŸäÿ≤* ‚Äì ÿ±ŸÅÿπ ŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ•ŸÑŸâ ŸÖŸÖŸäÿ≤\n' +
            'üîπ */ÿ™ŸÜÿ≤ŸäŸÑ ŸÖŸÖŸäÿ≤* ‚Äì ÿ™ŸÜÿ≤ŸäŸÑ ŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÖŸÜ ŸÖŸÖŸäÿ≤\n' +
            'üîπ */ŸÑÿ≥ÿ™ÿ© ŸÖŸÖŸäÿ≤* ‚Äì ÿπÿ±ÿ∂ ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖŸÖŸäÿ≤ŸäŸÜ\n' +
            'üîπ */ÿ™ÿ±ŸÇŸäÿ© ÿßÿØŸÖŸÜ* ‚Äì ÿ™ÿ±ŸÇŸäÿ© ÿ•ŸÑŸâ ÿ£ÿØŸÖŸÜ\n' +
            'üîπ */ÿ™ŸÜÿ≤ŸäŸÑ* ‚Äì ÿ•ÿ≤ÿßŸÑÿ© ÿ±ÿ™ÿ®ÿ© ÿßŸÑÿ£ÿØŸÖŸÜ\n' +
            'üîπ */ÿ™ÿ±ŸÇŸäÿ© ŸÖÿ∑Ÿàÿ±* ‚Äì ÿ™ÿ±ŸÇŸäÿ© ÿ•ŸÑŸâ ŸÖÿ∑Ÿàÿ±\n' +
            'üîπ */ÿ™ÿ±ŸÇŸäÿ© ŸÖÿ∑Ÿàÿ± ÿ´ÿßŸÜŸàŸä* ‚Äì ÿ™ÿ±ŸÇŸäÿ© ÿ•ŸÑŸâ ŸÖÿ∑Ÿàÿ± ÿ´ÿßŸÜŸàŸä\n' +
            'üîπ */ÿ™ŸÜÿ≤ŸäŸÑ ŸÖÿ∑Ÿàÿ±* ‚Äì ŸÑÿ™ŸÜÿ≤ŸäŸÑ ŸÖÿ∑Ÿàÿ± ÿ£ŸàŸÑ ÿ£Ÿà ÿ´ÿßŸÜŸàŸäÿå ÿßÿ∞Ÿáÿ® ÿ•ŸÑŸâ ÿÆÿßÿµ ÿßŸÑÿ®Ÿàÿ™ ŸÉŸÖÿ∑Ÿàÿ±\n' +
            'üîπ */ÿ±ÿßÿ®ÿ∑ ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ©* ‚Äì ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ±ÿßÿ®ÿ∑ ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ©\n' +
            'üîπ */ŸÜÿØÿßÿ° ÿßŸÑÿ¨ŸÖŸäÿπ* ‚Äì ŸÖŸÜÿßÿØÿßÿ© ÿ¨ŸÖŸäÿπ ÿßŸÑÿ£ÿπÿ∂ÿßÿ°\n' +
            'üîπ */ŸÉÿ™ŸÖ* ‚Äì ŸÉÿ™ŸÖ ŸÖÿ≥ÿ™ÿÆÿØŸÖ\n' +
            'üîπ */ÿßŸÑÿ∫ÿßÿ° ŸÉÿ™ŸÖ* ‚Äì ÿ•ŸÑÿ∫ÿßÿ° ŸÉÿ™ŸÖ ŸÖÿ≥ÿ™ÿÆÿØŸÖ\n' +
            'üîπ */ŸÖÿ≥ÿ≠* ‚Äì ÿ≠ÿ∞ŸÅ ÿ¢ÿÆÿ± ÿ±ÿ≥ÿßŸÑÿ©\n' +
            'üîπ */ÿ™ÿ´ÿ®Ÿäÿ™* ‚Äì ÿ™ÿ´ÿ®Ÿäÿ™ ÿ±ÿ≥ÿßŸÑÿ©\n' +
            'üîπ */ŸÜŸÉÿ™ÿ©* ‚Äì ÿ•ÿ±ÿ≥ÿßŸÑ ŸÜŸÉÿ™ÿ©\n' +
            'üîπ */ÿ∑ÿ±ÿØ* ‚Äì ÿ∑ÿ±ÿØ ŸÖÿ≥ÿ™ÿÆÿØŸÖ\n' +
            'üîπ */ÿ™ÿ≠ÿ∞Ÿäÿ±* ‚Äì ÿ•ÿµÿØÿßÿ± ÿ™ÿ≠ÿ∞Ÿäÿ± ŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ\n' +
            'üîπ */ÿ™ÿ≠ÿ∞Ÿäÿ±ÿßÿ™* ‚Äì ÿπÿ±ÿ∂ ÿπÿØÿØ ÿßŸÑÿ™ÿ≠ÿ∞Ÿäÿ±ÿßÿ™ ŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ\n';

        // Send the first part with a "Next" button
        await ctx.editMessageCaption(commandsPart1, {
            parse_mode: 'Markdown',
            reply_markup: {
                inline_keyboard: [
                    [{ text: '‚ö†Ô∏è ÿ•ÿØÿßÿ±ÿ© ÿßŸÑÿ™ÿ≠ÿ∞Ÿäÿ±ÿßÿ™', callback_data: 'manage_warnings' }],
                    [{ text: 'üîú ÿßŸÑÿ™ÿßŸÑŸä', callback_data: 'show_commands_part2' }],
                    [{ text: 'üîô ÿ±ÿ¨Ÿàÿπ', callback_data: 'back' }]
                ]
            }
        });

    } catch (error) {
        console.error('Error in show_commands action:', error);
        ctx.answerCbQuery('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿπÿ±ÿ∂ ÿßŸÑÿ£ŸàÿßŸÖÿ±. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ŸÑÿßÿ≠ŸÇŸãÿß.', { show_alert: true });
    }
});

// Handle the "Next" button to show the second part
bot.action('show_commands_part2', async (ctx) => {
    try {
        const commandsPart2 = 
            'üîπ */ŸÖÿ≥ÿ≠ ÿßŸÑÿµŸàÿ±* ‚Äì ÿ≠ÿ∞ŸÅ ÿ¢ÿÆÿ± ÿßŸÑÿµŸàÿ± ÿßŸÑŸÖÿ±ÿ≥ŸÑÿ©\n' +
            'üîπ */ŸÖŸÜÿπ ÿßŸÑÿµŸàÿ±* ‚Äì ŸÖŸÜÿπ ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿµŸàÿ±\n' +
            'üîπ */ÿ≥ŸÖÿßÿ≠ ÿßŸÑÿµŸàÿ±* ‚Äì ÿßŸÑÿ≥ŸÖÿßÿ≠ ÿ®ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿµŸàÿ±\n' +
            'üîπ */ÿßÿ≤ÿßŸÑÿ© ÿßŸÑÿ±Ÿàÿßÿ®ÿ∑* ‚Äì ÿ≠ÿ∞ŸÅ ÿßŸÑÿ±Ÿàÿßÿ®ÿ∑ ŸÅŸä ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ©\n' +
            'üîπ */ŸÅÿ™ÿ≠ ÿ±Ÿàÿßÿ®ÿ∑* ‚Äì ÿßŸÑÿ≥ŸÖÿßÿ≠ ÿ®ŸÖÿ¥ÿßÿ±ŸÉÿ© ÿßŸÑÿ±Ÿàÿßÿ®ÿ∑\n' +
            'üîπ */ÿ∫ŸÑŸÇ ÿ±Ÿàÿßÿ®ÿ∑* ‚Äì ŸÖŸÜÿπ ŸÖÿ¥ÿßÿ±ŸÉÿ© ÿßŸÑÿ±Ÿàÿßÿ®ÿ∑\n' +
            'üîπ */ŸÖŸÜÿπ ŸÅŸäÿØŸäŸà* ‚Äì ŸÖŸÜÿπ ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑŸÅŸäÿØŸäŸàŸáÿßÿ™\n' +
            'üîπ */ÿ™ŸÅÿπŸäŸÑ ŸÅŸäÿØŸäŸà* ‚Äì ÿßŸÑÿ≥ŸÖÿßÿ≠ ÿ®ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑŸÅŸäÿØŸäŸàŸáÿßÿ™\n' +
            'üîπ */ŸÖŸÜÿπ ŸÖÿ™ÿ≠ÿ±ŸÉÿ©* ‚Äì ŸÖŸÜÿπ ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿµŸàÿ± ÿßŸÑŸÖÿ™ÿ≠ÿ±ŸÉÿ©\n' +
            'üîπ */ÿ™ŸÅÿπŸäŸÑ ŸÖÿ™ÿ≠ÿ±ŸÉÿ©* ‚Äì ÿßŸÑÿ≥ŸÖÿßÿ≠ ÿ®ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿµŸàÿ± ÿßŸÑŸÖÿ™ÿ≠ÿ±ŸÉÿ©';

        await ctx.editMessageCaption(commandsPart2, {
            parse_mode: 'Markdown',
            reply_markup: {
                inline_keyboard: [
                    [{ text: 'üîô ÿ±ÿ¨Ÿàÿπ', callback_data: 'show_commands' }]
                ]
            }
        });

    } catch (error) {
        console.error('Error in show_commands_part2 action:', error);
        ctx.answerCbQuery('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿπÿ±ÿ∂ ÿßŸÑÿ£ŸàÿßŸÖÿ±. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ŸÑÿßÿ≠ŸÇŸãÿß.', { show_alert: true });
    }
});
// Add a new action handler for managing warnings
bot.action('manage_warnings', async (ctx) => {
    try {
        const userId = ctx.from.id;
        const botId = ctx.botInfo.id;
        const chatId = ctx.chat.id;

        // Check if the user has the required permissions
        if (!await hasRequiredPermissions(ctx, userId)) {
            return ctx.answerCbQuery('‚ùå Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ± ŸÖÿÆÿµÿµ ŸÑŸÑŸÖÿ¥ÿ±ŸÅŸäŸÜ ŸàÿßŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ ÿßŸÑÿ´ÿßŸÜŸàŸäŸäŸÜ ŸÅŸÇÿ∑.', { show_alert: true });
        }

        // Fetch current warning settings for this bot and group
        const warningSettings = await getWarningSettings(botId, chatId);

        // Display the current settings and options to change them
        const message = `‚ö†Ô∏è ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑÿ™ÿ≠ÿ∞Ÿäÿ±ÿßÿ™ ÿßŸÑÿ≠ÿßŸÑŸäÿ©:\n\n` +
                        `ÿπÿØÿØ ÿßŸÑÿ™ÿ≠ÿ∞Ÿäÿ±ÿßÿ™ ŸÇÿ®ŸÑ ÿßŸÑÿ∑ÿ±ÿØ: ${warningSettings.kick || 'ÿ∫Ÿäÿ± ŸÖÿ≠ÿØÿØ'}\n` +
                        `ÿπÿØÿØ ÿßŸÑÿ™ÿ≠ÿ∞Ÿäÿ±ÿßÿ™ ŸÇÿ®ŸÑ ÿßŸÑŸÉÿ™ŸÖ: ${warningSettings.mute || 'ÿ∫Ÿäÿ± ŸÖÿ≠ÿØÿØ'}\n` +
                        `ÿπÿØÿØ ÿßŸÑÿ™ÿ≠ÿ∞Ÿäÿ±ÿßÿ™ ŸÇÿ®ŸÑ ŸÖŸÜÿπ ÿßŸÑŸàÿ≥ÿßÿ¶ÿ∑: ${warningSettings.restrictMedia || 'ÿ∫Ÿäÿ± ŸÖÿ≠ÿØÿØ'}`;

        // Check if the message to be edited is a text message
        if (ctx.callbackQuery.message.text) {
            await ctx.editMessageText(message, {
                reply_markup: {
                    inline_keyboard: [
                        [{ text: 'ÿ™ÿπÿØŸäŸÑ ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑÿ∑ÿ±ÿØ', callback_data: `edit_warning_kick:${botId}:${chatId}` }],
                        [{ text: 'ÿ™ÿπÿØŸäŸÑ ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑŸÉÿ™ŸÖ', callback_data: `edit_warning_mute:${botId}:${chatId}` }],
                        [{ text: 'ÿ™ÿπÿØŸäŸÑ ÿ•ÿπÿØÿßÿØÿßÿ™ ŸÖŸÜÿπ ÿßŸÑŸàÿ≥ÿßÿ¶ÿ∑', callback_data: `edit_warning_restrict_media:${botId}:${chatId}` }],
                        [{ text: 'üîô ÿ±ÿ¨Ÿàÿπ', callback_data: 'show_commands' }]
                    ]
                }
            });
        } else {
            // If not a text message, send a new message
            await ctx.reply(message, {
                reply_markup: {
                    inline_keyboard: [
                        [{ text: 'ÿ™ÿπÿØŸäŸÑ ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑÿ∑ÿ±ÿØ', callback_data: `edit_warning_kick:${botId}:${chatId}` }],
                        [{ text: 'ÿ™ÿπÿØŸäŸÑ ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑŸÉÿ™ŸÖ', callback_data: `edit_warning_mute:${botId}:${chatId}` }],
                        [{ text: 'ÿ™ÿπÿØŸäŸÑ ÿ•ÿπÿØÿßÿØÿßÿ™ ŸÖŸÜÿπ ÿßŸÑŸàÿ≥ÿßÿ¶ÿ∑', callback_data: `edit_warning_restrict_media:${botId}:${chatId}` }],
                        [{ text: 'üîô ÿ±ÿ¨Ÿàÿπ', callback_data: 'show_commands' }]
                    ]
                }
            });
        }
    } catch (error) {
        console.error('Error managing warnings:', error);
        await ctx.reply('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ•ÿØÿßÿ±ÿ© ÿßŸÑÿ™ÿ≠ÿ∞Ÿäÿ±ÿßÿ™.');
    }
});
const { getLeaderboard } = require('./database');

// ... other code ...

bot.action('show_leaderboard', async (ctx) => {
    try {
        await ctx.answerCbQuery();

        // Get the chat ID from the callback context
        const chatId = ctx.chat?.id || ctx.callbackQuery.message.chat.id;
        
        console.log(`Fetching leaderboard for chat ID: ${chatId}`);

        // Fetch leaderboard data for this specific group
        const leaderboardData = await database.getLeaderboard(chatId);
        
        console.log(`Leaderboard data received, entries: ${leaderboardData.length}`);
        
        let leaderboardText = "üèÜ ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ™ÿµÿØÿ±ŸäŸÜ ŸÅŸä Ÿáÿ∞Ÿá ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ©:\n\n";

        if (leaderboardData && leaderboardData.length > 0) {
            // Add medals for top 3
            const medals = ['ü•á', 'ü•à', 'ü•â'];
            
            leaderboardData.forEach((entry, index) => {
                const name = entry.firstName || entry.username || 'ŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÖÿ¨ŸáŸàŸÑ';
                const prefix = index < 3 ? medals[index] : `${index + 1}.`;
                leaderboardText += `${prefix} ${name}: ${entry.totalScore} ŸÜŸÇÿ∑ÿ©\n`;
            });
        } else {
            leaderboardText += "ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÜÿ™ÿßÿ¶ÿ¨ ÿ®ÿπÿØ.";
        }

        const replyMarkup = {
            inline_keyboard: [
                [{ text: 'üîô ÿßŸÑÿπŸàÿØÿ© ŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ≥ÿßÿ®ŸÇÿßÿ™', callback_data: 'back_to_quiz_menu' }]
            ]
        };

        // Edit the message with the leaderboard
        if (ctx.callbackQuery.message.photo) {
            await ctx.editMessageCaption(leaderboardText, {
                reply_markup: replyMarkup
            });
        } else {
            await ctx.editMessageText(leaderboardText, {
                reply_markup: replyMarkup
            });
        }
    } catch (error) {
        console.error('Error showing leaderboard:', error);
        await ctx.answerCbQuery('ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿπÿ±ÿ∂ ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ™ÿµÿØÿ±ŸäŸÜ.');
        await ctx.reply('ÿπÿ∞ÿ±Ÿãÿßÿå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ŸÖÿ≠ÿßŸàŸÑÿ© ÿπÿ±ÿ∂ ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ™ÿµÿØÿ±ŸäŸÜ. ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ŸÑÿßÿ≠ŸÇŸãÿß.');
    }
})


 // Register session middleware
//bot.use(Scenes.session());
 

// Add a button in the quiz menu for adding questions
bot.action('add_quiz_question', async (ctx) => {
    try {
        await ctx.answerCbQuery();
        
        // Check if user is admin or developer
        const isAdmin = await isAdminOrOwner(ctx, ctx.from.id);
        const isDev = await isDeveloper(ctx, ctx.from.id);
        
        if (!isAdmin && !isDev) {
            return ctx.reply('‚ùå Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ± ŸÖÿ™ÿßÿ≠ ŸÅŸÇÿ∑ ŸÑŸÑŸÖÿ¥ÿ±ŸÅŸäŸÜ ŸàÿßŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ.');
        }
        
        await ctx.scene.enter('add_question_wizard');
    } catch (error) {
        console.error('Error entering add question wizard:', error);
        await ctx.reply('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ŸÖÿ≠ÿßŸàŸÑÿ© ÿ•ÿ∂ÿßŸÅÿ© ÿ≥ÿ§ÿßŸÑ ÿ¨ÿØŸäÿØ.');
    }
});
bot.action('back_to_quiz_menu', async (ctx) => {
    try {
        await ctx.answerCbQuery();
        await showQuizMenu(ctx);
    } catch (error) {
        console.error('Error returning to quiz menu:', error);
        await ctx.answerCbQuery('ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿßŸÑÿπŸàÿØÿ© ŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ≥ÿßÿ®ŸÇÿßÿ™.');
    }
});
// Implement other helper functions similarly...
 
bot.action(/^add_general_reply:(\d+)$/, async (ctx) => {
    const botId = parseInt(ctx.match[1]);
    if (await isDeveloper(ctx, ctx.from.id)) {
        await ctx.answerCbQuery('ÿ•ÿ∂ÿßŸÅÿ© ÿ±ÿØ ÿπÿßŸÖ');
        ctx.reply('ÿ£ÿ±ÿ≥ŸÑ ÿßŸÑŸÉŸÑŸÖÿ© ÿßŸÑÿ™Ÿä ÿ™ÿ±ŸäÿØ ÿ•ÿ∂ÿßŸÅÿ© ÿ±ÿØ ŸÑŸáÿß:');
        
        // Use userStates instead of userState
        userStates.set(ctx.from.id, {
            action: 'adding_reply',
            step: 'awaiting_trigger',
            botId: botId
        });
    } else {
        ctx.answerCbQuery('ÿπÿ∞ÿ±Ÿãÿßÿå Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ± ŸÑŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ ŸÅŸÇÿ∑', { show_alert: true });
    }
});
          

bot.action('cancel_add_reply', async (ctx) => {
    try {
        await ctx.answerCbQuery('ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ±ÿØ');
        userStates.delete(ctx.from.id);
        await ctx.editMessageText('ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿπŸÖŸÑŸäÿ© ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ±ÿØ. ŸäŸÖŸÉŸÜŸÉ ÿ®ÿØÿ° ÿßŸÑÿπŸÖŸÑŸäÿ© ŸÖŸÜ ÿ¨ÿØŸäÿØ ŸÅŸä ÿ£Ÿä ŸàŸÇÿ™.');
    } catch (error) {
        console.error('Error canceling add reply:', error);
        await ctx.answerCbQuery('ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ•ŸÑÿ∫ÿßÿ° ÿßŸÑÿπŸÖŸÑŸäÿ©.', { show_alert: true });
    }
});
    // Modify the delete_general_reply action handler
    bot.action(/^delete_general_reply:(\d+)$/, async (ctx) => {
        try {
            const botId = ctx.match[1];
            const userId = ctx.from.id;
    
            if (await isDeveloper(ctx, userId)) {
                const db = await ensureDatabaseInitialized(botId);
                
                // Fetch all replies for this bot
                const replies = await db.collection('replies').find({ bot_id: botId }).toArray();
                
                if (replies.length === 0) {
                    await ctx.answerCbQuery('ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ±ÿØŸàÿØ ŸÑÿ≠ÿ∞ŸÅŸáÿß.', { show_alert: true });
                    return;
                }
    
                // Create inline keyboard with reply options
                const keyboard = replies.map(reply => [{
                    text: reply.trigger_word,
                    callback_data: `confirm_delete_reply:${botId}:${reply._id}`
                }]);
    
                keyboard.push([{ text: 'ÿ•ŸÑÿ∫ÿßÿ°', callback_data: `cancel_delete_reply:${botId}` }]);
    
                await ctx.editMessageText('ÿßÿÆÿ™ÿ± ÿßŸÑÿ±ÿØ ÿßŸÑÿ∞Ÿä ÿ™ÿ±ŸäÿØ ÿ≠ÿ∞ŸÅŸá:', {
                    reply_markup: { inline_keyboard: keyboard }
                });
            } else {
                await ctx.answerCbQuery('ÿπÿ∞ÿ±Ÿãÿßÿå Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ± ŸÑŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ ŸÅŸÇÿ∑', { show_alert: true });
            }
        } catch (error) {
            console.error('Error in delete_general_reply action:', error);
            await ctx.answerCbQuery('ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ŸÖÿ≠ÿßŸàŸÑÿ© ÿ≠ÿ∞ŸÅ ÿßŸÑÿ±ÿØ. ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.', { show_alert: true });
        }
    });
    bot.action(/^delete_all_replies:(\d+)$/, async (ctx) => {
        try {
            const botId = ctx.match[1];
            const userId = ctx.from.id;
    
            if (await isDeveloper(ctx, userId)) {
                await ctx.answerCbQuery();
                await ctx.editMessageText('ŸáŸÑ ÿ£ŸÜÿ™ ŸÖÿ™ÿ£ŸÉÿØ ÿ£ŸÜŸÉ ÿ™ÿ±ŸäÿØ ÿ≠ÿ∞ŸÅ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ±ÿØŸàÿØ ŸÑŸáÿ∞ÿß ÿßŸÑÿ®Ÿàÿ™ÿü', {
                    reply_markup: {
                        inline_keyboard: [
                            [{ text: 'ŸÜÿπŸÖÿå ÿßÿ≠ÿ∞ŸÅ ÿßŸÑŸÉŸÑ', callback_data: `confirm_delete_all_replies:${botId}` }],
                            [{ text: 'ÿ•ŸÑÿ∫ÿßÿ°', callback_data: `cancel_delete_all_replies:${botId}` }]
                        ]
                    }
                });
            } else {
                await ctx.answerCbQuery('ÿπÿ∞ÿ±Ÿãÿßÿå Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ± ŸÑŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ ŸÅŸÇÿ∑', { show_alert: true });
            }
        } catch (error) {
            console.error('Error in delete_all_replies action:', error);
            await ctx.answerCbQuery('ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ŸÖÿ≠ÿßŸàŸÑÿ© ÿ≠ÿ∞ŸÅ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ±ÿØŸàÿØ. ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.', { show_alert: true });
        }
    });

    bot.action(/^confirm_delete_all_replies:(\d+)$/, async (ctx) => {
        try {
            const botId = ctx.match[1];
            const db = await ensureDatabaseInitialized(botId);
            await db.collection('replies').deleteMany({ bot_id: botId });
            await ctx.answerCbQuery('ÿ™ŸÖ ÿ≠ÿ∞ŸÅ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ±ÿØŸàÿØ ÿ®ŸÜÿ¨ÿßÿ≠');
            await ctx.editMessageText('ÿ™ŸÖ ÿ≠ÿ∞ŸÅ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ±ÿØŸàÿØ ŸÑŸáÿ∞ÿß ÿßŸÑÿ®Ÿàÿ™.', {
                reply_markup: {
                    inline_keyboard: [[{ text: 'ÿ±ÿ¨Ÿàÿπ', callback_data: `back_to_replies_menu:${botId}` }]]
                }
            });
        } catch (error) {
            console.error('Error in confirm_delete_all_replies action:', error);
            await ctx.answerCbQuery('ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ≠ÿ∞ŸÅ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ±ÿØŸàÿØ. ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.', { show_alert: true });
        }
    });
    
    bot.action(/^cancel_delete_all_replies:(\d+)$/, async (ctx) => {
        const botId = ctx.match[1];
        await ctx.answerCbQuery('ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿπŸÖŸÑŸäÿ© ÿ≠ÿ∞ŸÅ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ±ÿØŸàÿØ');
        await ctx.editMessageText('ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿπŸÖŸÑŸäÿ© ÿ≠ÿ∞ŸÅ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ±ÿØŸàÿØ.', {
            reply_markup: {
                inline_keyboard: [[{ text: 'ÿ±ÿ¨Ÿàÿπ', callback_data: `back_to_replies_menu:${botId}` }]]
            }
        });
    });
// Additional actions for confirmation and cancellation

bot.action(/^confirm_delete_reply:(\d+):(.+)$/, async (ctx) => {
    try {
        const [botId, replyId] = ctx.match.slice(1);
        const db = await ensureDatabaseInitialized(botId);
        await db.collection('replies').deleteOne({ _id: ObjectId(replyId), bot_id: botId });
        await ctx.answerCbQuery('ÿ™ŸÖ ÿ≠ÿ∞ŸÅ ÿßŸÑÿ±ÿØ ÿ®ŸÜÿ¨ÿßÿ≠');
        await ctx.editMessageText('ÿ™ŸÖ ÿ≠ÿ∞ŸÅ ÿßŸÑÿ±ÿØ. ŸáŸÑ ÿ™ÿ±ŸäÿØ ÿ≠ÿ∞ŸÅ ÿ±ÿØ ÿ¢ÿÆÿ±ÿü', {
            reply_markup: {
                inline_keyboard: [
                    [{ text: 'ÿ≠ÿ∞ŸÅ ÿ±ÿØ ÿ¢ÿÆÿ±', callback_data: `delete_general_reply:${botId}` }],
                    [{ text: 'ÿ±ÿ¨Ÿàÿπ', callback_data: `back_to_replies_menu:${botId}` }]
                ]
            }
        });
    } catch (error) {
        console.error('Error in confirm_delete_reply action:', error);
        await ctx.answerCbQuery('ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ≠ÿ∞ŸÅ ÿßŸÑÿ±ÿØ. ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.', { show_alert: true });
    }
});
bot.action(/^back_to_replies_menu:(\d+)$/, async (ctx) => {
    const botId = ctx.match[1];
    await ctx.answerCbQuery();
    await ctx.editMessageText('ŸÇÿßÿ¶ŸÖÿ© ÿ•ÿØÿßÿ±ÿ© ÿßŸÑÿ±ÿØŸàÿØ ÿßŸÑÿπÿßŸÖÿ©:', {
        reply_markup: {
            inline_keyboard: [
                [{ text: 'ÿ•ÿ∂ÿßŸÅÿ© ÿ±ÿØ ÿ¨ÿØŸäÿØ', callback_data: `add_general_reply:${botId}` }],
                [{ text: 'ÿ≠ÿ∞ŸÅ ÿ±ÿØ', callback_data: `delete_general_reply:${botId}` }],
                [{ text: 'ÿπÿ±ÿ∂ ÿßŸÑÿ±ÿØŸàÿØ', callback_data: `list_general_replies:${botId}` }],
                [{ text: 'ÿ≠ÿ∞ŸÅ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ±ÿØŸàÿØ', callback_data: `delete_all_replies:${botId}` }],
                [{ text: 'ÿ±ÿ¨Ÿàÿπ ŸÑŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©', callback_data: 'back_to_main_menu' }]
            ]
        }
    });
});
bot.action(/^cancel_delete_reply:(\d+)$/, async (ctx) => {
    const botId = ctx.match[1];
    await ctx.answerCbQuery('ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿπŸÖŸÑŸäÿ© ÿßŸÑÿ≠ÿ∞ŸÅ');
    await ctx.editMessageText('ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿπŸÖŸÑŸäÿ© ÿ≠ÿ∞ŸÅ ÿßŸÑÿ±ÿØ.', {
        reply_markup: {
            inline_keyboard: [[{ text: 'ÿ±ÿ¨Ÿàÿπ', callback_data: `back_to_replies_menu:${botId}` }]]
        }
    });
});
// Handle the "ÿßŸÑÿ•ÿ∞ÿßÿπÿ©" button press
bot.action('dev_broadcast', async (ctx) => {
    try {
        await ctx.answerCbQuery();
        awaitingBroadcastPhoto = true;

        await ctx.reply(
`üì¢ Ÿàÿ∂ÿπ ÿßŸÑÿ•ÿ∞ÿßÿπÿ© ŸÖŸÅÿπŸÑ!

üì∏ ÿßŸÑÿ±ÿ¨ÿßÿ° ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿµŸàÿ±ÿ© ÿ£Ÿà ÿßŸÑŸàÿ≥ÿßÿ¶ÿ∑ ÿßŸÑÿ™Ÿä ÿ™ÿ±ŸäÿØ ÿ•ÿ∞ÿßÿπÿ™Ÿáÿß ÿßŸÑÿ¢ŸÜ.

üõë üü© ŸÑÿ•ŸäŸÇÿßŸÅ Ÿàÿ™ÿ¥ÿ∫ŸäŸÑ Ÿáÿ∞ÿß ÿßŸÑŸàÿ∂ÿπ ŸäÿØŸàŸäŸãÿßÿå ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ£ŸÖÿ±: /broadcast
ŸÖÿ´ÿßŸÑ ÿπŸÜÿØ ÿßŸÑÿ™ÿ¥ŸÅŸäŸÑ : üì¢ Ÿàÿ∂ÿπ ÿßŸÑÿ•ÿ∞ÿßÿπÿ© ŸÖŸÅÿπŸÑ. ŸäŸÖŸÉŸÜŸÉ ÿßŸÑÿ¢ŸÜ ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿµŸàÿ± ŸÑŸÑÿ®ÿ´. ÿ¥ÿ∫ÿßŸÑ ‚úÖ
ŸÖÿ´ÿßŸÑ ÿπŸÜÿØ ÿßŸÑÿßŸäŸÇÿßŸÅ : üõë ÿ™ŸÖ ÿ•ŸäŸÇÿßŸÅ Ÿàÿ∂ÿπ ÿßŸÑÿ•ÿ∞ÿßÿπÿ©. ŸÖŸà ÿ¥ÿ∫ÿßŸÑ ‚ùå


`
        );
    } catch (error) {
        console.error('Error handling broadcast action:', error);
        await ctx.reply('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ŸÖÿ≠ÿßŸàŸÑÿ© ÿ®ÿØÿ° ÿßŸÑÿ•ÿ∞ÿßÿπÿ©.');
    }
});


// Add action handlers for editing warning settings
bot.action(/^edit_warning_kick:(\d+):(\d+)$/, async (ctx) => {
    const [botId, chatId] = ctx.match.slice(1);
    await ctx.answerCbQuery();
    await ctx.reply('ÿ£ÿØÿÆŸÑ ÿπÿØÿØ ÿßŸÑÿ™ÿ≠ÿ∞Ÿäÿ±ÿßÿ™ ŸÇÿ®ŸÑ ÿßŸÑÿ∑ÿ±ÿØ:');
    // Store the state for the user
    userStates.set(ctx.from.id, { action: 'edit_warning_kick', botId, chatId });
});

bot.action(/^edit_warning_mute:(\d+):(\d+)$/, async (ctx) => {
    const [botId, chatId] = ctx.match.slice(1);
    await ctx.answerCbQuery();
    await ctx.reply('ÿ£ÿØÿÆŸÑ ÿπÿØÿØ ÿßŸÑÿ™ÿ≠ÿ∞Ÿäÿ±ÿßÿ™ ŸÇÿ®ŸÑ ÿßŸÑŸÉÿ™ŸÖ:');
    userStates.set(ctx.from.id, { action: 'edit_warning_mute', botId, chatId });
});

bot.action(/^edit_warning_restrict_media:(\d+):(\d+)$/, async (ctx) => {
    const [botId, chatId] = ctx.match.slice(1);
    await ctx.answerCbQuery();
    await ctx.reply('ÿ£ÿØÿÆŸÑ ÿπÿØÿØ ÿßŸÑÿ™ÿ≠ÿ∞Ÿäÿ±ÿßÿ™ ŸÇÿ®ŸÑ ŸÖŸÜÿπ ÿßŸÑŸàÿ≥ÿßÿ¶ÿ∑:');
    userStates.set(ctx.from.id, { action: 'edit_warning_restrict_media', botId, chatId });
});

    bot.action(/^list_general_replies:(\d+)$/, async (ctx) => {
        try {
            const botId = parseInt(ctx.match[1]);
            const userId = ctx.from.id;
    
            if (await isDeveloper(ctx, userId)) {
                await ctx.answerCbQuery('ÿπÿ±ÿ∂ ÿßŸÑÿ±ÿØŸàÿØ ÿßŸÑÿπÿßŸÖÿ©');
                
                const db = await ensureDatabaseInitialized(botId);
                const replies = await db.collection('replies').find({ bot_id: botId }).toArray();
    
                let replyList = 'ÿßŸÑÿ±ÿØŸàÿØ ÿßŸÑÿπÿßŸÖÿ©:\n\n';
                if (replies.length > 0) {
                    replies.forEach((reply, index) => {
                        replyList += `${index + 1}. ÿßŸÑŸÉŸÑŸÖÿ©: ${reply.trigger_word}\nÿßŸÑÿ±ÿØ: ${reply.reply_text}\n\n`;
                    });
                } else {
                    replyList += 'ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ±ÿØŸàÿØ ÿπÿßŸÖÿ© ÿ≠ÿßŸÑŸäÿßŸã.';
                }
    
                // Split the message if it's too long
                const maxLength = 4096; // Telegram's max message length
                if (replyList.length > maxLength) {
                    const chunks = replyList.match(new RegExp(`.{1,${maxLength}}`, 'g'));
                    for (let i = 0; i < chunks.length; i++) {
                        if (i === 0) {
                            await ctx.editMessageText(chunks[i], {
                                reply_markup: {
                                    inline_keyboard: [[{ text: 'ÿ±ÿ¨Ÿàÿπ', callback_data: `back_to_replies_menu:${botId}` }]]
                                }
                            });
                        } else {
                            await ctx.reply(chunks[i]);
                        }
                    }
                } else {
                    await ctx.editMessageText(replyList, {
                        reply_markup: {
                            inline_keyboard: [[{ text: 'ÿ±ÿ¨Ÿàÿπ', callback_data: `back_to_replies_menu:${botId}` }]]
                        }
                    });
                }
            } else {
                await ctx.answerCbQuery('ÿπÿ∞ÿ±ÿßŸãÿå Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ± ŸÑŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ ŸÅŸÇÿ∑', { show_alert: true });
            }
        } catch (error) {
            console.error('Error in list_general_replies action:', error);
            await ctx.answerCbQuery('ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿπÿ±ÿ∂ ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ±ÿØŸàÿØ. ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.', { show_alert: true });
        }
    });
    
    // Add this callback handler for the start_quiz button
    bot.action('start_quiz', async (ctx) => {
        try {
            await ctx.answerCbQuery();
            const chatId = ctx.chat.id;
            const userId = ctx.from.id;
    
            // Check if the user is an admin, developer, or VIP
            const isAdmin = await isAdminOrOwner(ctx, userId);
            const isDev = await isDeveloper(ctx, userId);
            const vipStatus = await isVIP(ctx, userId);

    
            if (!isAdmin && !isDev && !vipStatus) {

                return ctx.reply('‚ùå ÿπÿ∞ÿ±ÿßŸãÿå Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ± ŸÖÿ™ÿßÿ≠ ŸÅŸÇÿ∑ ŸÑŸÑŸÖÿ¥ÿ±ŸÅŸäŸÜ ŸàÿßŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ ŸàÿßŸÑŸÖŸÖŸäÿ≤ŸäŸÜ (VIP).');
            }
    
            // Initialize a new quiz for this chat
            activeQuizzes.set(chatId, {
                state: QUIZ_STATE.SELECTING_DIFFICULTY,
                difficulty: null,
                questions: [],
                currentQuestionIndex: 0,
                scores: new Map(),
                attempts: new Map(),
                timeouts: []
            });
    
            const difficultyKeyboard = {
                inline_keyboard: [
                    [{ text: 'üòä ÿ≥ŸáŸÑ', callback_data: 'difficulty_easy' }],
                    [{ text: 'ü§î ŸÖÿ™Ÿàÿ≥ÿ∑', callback_data: 'difficulty_medium' }],
                    [{ text: 'üò® ÿµÿπÿ®', callback_data: 'difficulty_hard' }],
                    [{ text: 'üé≤ ÿ£ÿ≥ÿ¶ŸÑÿ© ŸÖÿÆÿµÿµÿ©', callback_data: 'difficulty_custom' }],
                    [{ text: 'üîô ÿßŸÑÿπŸàÿØÿ©', callback_data: 'back_to_quiz_menu' }]
                ]
            };
    
            const questionCountKeyboard = {
                inline_keyboard: [
                    [
                        { text: '10', callback_data: 'count_10' },
                        { text: '25', callback_data: 'count_25' },
                        { text: '35', callback_data: 'count_35' }
                    ],
                    [
                        { text: '50', callback_data: 'count_50' },
                        { text: '75', callback_data: 'count_75' },
                        { text: '100', callback_data: 'count_100' }
                    ],
                    [{ text: 'üîô ÿßŸÑÿπŸàÿØÿ©', callback_data: 'back_to_quiz_menu' }]
                ]
            };
    
            const combinedKeyboard = {
                inline_keyboard: [
                    ...difficultyKeyboard.inline_keyboard,
                    [{ text: 'üî¢ ÿßÿÆÿ™ÿ± ÿπÿØÿØ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ©', callback_data: 'select_question_count' }]
                ]
            };
    
            const combinedText = `ÿßÿÆÿ™ÿ± ŸÖÿ≥ÿ™ŸàŸâ ÿµÿπŸàÿ®ÿ© ÿßŸÑŸÖÿ≥ÿßÿ®ŸÇÿ©:\n\nüî¢ ÿßÿÆÿ™ÿ± ÿπÿØÿØ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ŸÑŸÑŸÖÿ≥ÿßÿ®ŸÇÿ©:`;
    
            if (ctx.callbackQuery.message.photo) {
                // If the current message is a photo, edit the caption
                await ctx.editMessageCaption(combinedText, { reply_markup: combinedKeyboard });
            } else {
                // If it's a text message, edit the text
                await ctx.editMessageText(combinedText, { reply_markup: combinedKeyboard });
            }
    
            // Add a custom field to track who started the quiz
            activeQuizzes.get(chatId).startedBy = {
                id: userId,
                name: ctx.from.first_name,
                isAdmin: isAdmin,
                isDev: isDev,
                isVIP: isVIP
            };
    
        } catch (error) {
            console.error('Error handling start_quiz action:', error);
            await ctx.reply('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ®ÿØÿ° ÿßŸÑŸÖÿ≥ÿßÿ®ŸÇÿ© ÿßŸÑÿ¨ÿØŸäÿØÿ©.');
        }
    });

    bot.action('difficulty_custom', async (ctx) => {
        try {
            await ctx.answerCbQuery();
            const chatId = ctx.chat.id;
            
            // Check if there's an active quiz in the correct state
            if (!activeQuizzes.has(chatId) || activeQuizzes.get(chatId).state !== QUIZ_STATE.SELECTING_DIFFICULTY) {
                return ctx.reply('‚ùå ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÖÿ≥ÿßÿ®ŸÇÿ© ŸÜÿ¥ÿ∑ÿ© ŸÅŸä ÿ≠ÿßŸÑÿ© ÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑÿµÿπŸàÿ®ÿ©.');
            }
            
            // Update quiz state with selected difficulty
            const quiz = activeQuizzes.get(chatId);
            quiz.difficulty = 'custom';
            quiz.state = QUIZ_STATE.SELECTING_QUESTION_COUNT;
            
            // Show question count selection keyboard
            const questionCountKeyboard = {
                inline_keyboard: [
                    [
                        { text: '10', callback_data: 'count_10' },
                        { text: '25', callback_data: 'count_25' },
                        { text: '35', callback_data: 'count_35' }
                    ],
                    [
                        { text: '50', callback_data: 'count_50' },
                        { text: '75', callback_data: 'count_75' },
                        { text: '100', callback_data: 'count_100' }
                    ],
                    [{ text: 'üîô ÿßŸÑÿπŸàÿØÿ©', callback_data: 'back_to_quiz_menu' }]
                ]
            };
            
            const text = `ÿ™ŸÖ ÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ÿßŸÑŸÖÿÆÿµÿµÿ©\n\nüî¢ ÿßÿÆÿ™ÿ± ÿπÿØÿØ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ŸÑŸÑŸÖÿ≥ÿßÿ®ŸÇÿ©:`;
            
            if (ctx.callbackQuery.message.photo) {
                await ctx.editMessageCaption(text, { reply_markup: questionCountKeyboard });
            } else {
                await ctx.editMessageText(text, { reply_markup: questionCountKeyboard });
            }
        } catch (error) {
            console.error('Error selecting custom difficulty:', error);
            await ctx.reply('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ÿßŸÑŸÖÿÆÿµÿµÿ©. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.');
        }
    });

    // Add a new action handler for selecting question count
bot.action('select_question_count', async (ctx) => {
    try {
        await ctx.answerCbQuery();
        const questionCountKeyboard = {
            inline_keyboard: [
                [
                    { text: '10', callback_data: 'count_10' },
                    { text: '25', callback_data: 'count_25' },
                    { text: '35', callback_data: 'count_35' }
                ],
                [
                    { text: '50', callback_data: 'count_50' },
                    { text: '75', callback_data: 'count_75' },
                    { text: '100', callback_data: 'count_100' }
                ],
                [{ text: 'üîô ÿßŸÑÿπŸàÿØÿ©', callback_data: 'back_to_quiz_menu' }]
            ]
        };

        const text = 'üî¢ ÿßÿÆÿ™ÿ± ÿπÿØÿØ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ŸÑŸÑŸÖÿ≥ÿßÿ®ŸÇÿ©:';

        if (ctx.callbackQuery.message.photo) {
            await ctx.editMessageCaption(text, { reply_markup: questionCountKeyboard });
        } else {
            await ctx.editMessageText(text, { reply_markup: questionCountKeyboard });
        }
    } catch (error) {
        console.error('Error handling select_question_count action:', error);
        await ctx.reply('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿßÿÆÿ™Ÿäÿßÿ± ÿπÿØÿØ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ©.');
    }
});

// Add a handler for the back button to return to the quiz menu
bot.action('back_to_quiz_menu', async (ctx) => {
    try {
        await ctx.answerCbQuery();
        await showQuizMenu(ctx);
    } catch (error) {
        console.error('Error returning to quiz menu:', error);
        await ctx.reply('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿßŸÑÿπŸàÿØÿ© ŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ≥ÿßÿ®ŸÇÿßÿ™.');
    }
});
// Add these action handlers
bot.action(/^quiz_timer_(\d+)$/, async (ctx) => {
    try {
        const chatId = ctx.chat.id;
        const newTimer = parseInt(ctx.match[1]);
        
        // Update the quiz settings for this chat
        quizSettings.set(chatId, { ...quizSettings.get(chatId), timer: newTimer });
        
        await ctx.answerCbQuery(`ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿ´ ŸàŸÇÿ™ ÿßŸÑÿ≥ÿ§ÿßŸÑ ÿ•ŸÑŸâ ${newTimer} ÿ´ÿßŸÜŸäÿ©`);
        await ctx.editMessageText(`ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿ´ ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑŸÖÿ≥ÿßÿ®ŸÇÿ©.\nŸàŸÇÿ™ ÿßŸÑÿ≥ÿ§ÿßŸÑ ÿßŸÑÿ¨ÿØŸäÿØ: ${newTimer} ÿ´ÿßŸÜŸäÿ©`);
    } catch (error) {
        console.error('Error updating quiz timer:', error);
        await ctx.answerCbQuery('ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™.');
    }
});

bot.action('show_current_timer', async (ctx) => {
    try {
        const chatId = ctx.chat.id;
        const currentTimer = quizSettings.get(chatId)?.timer || 30; // Default to 30 seconds if not set
        await ctx.answerCbQuery(`ÿßŸÑŸàŸÇÿ™ ÿßŸÑÿ≠ÿßŸÑŸä ŸÑŸÑÿ≥ÿ§ÿßŸÑ: ${currentTimer} ÿ´ÿßŸÜŸäÿ©`);
    } catch (error) {
        console.error('Error showing current timer:', error);
        await ctx.answerCbQuery('ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿπÿ±ÿ∂ ÿßŸÑŸàŸÇÿ™ ÿßŸÑÿ≠ÿßŸÑŸä.');
    }
});
// Handle difficulty selection
bot.action(/^difficulty_(.+)$/, async (ctx) => {
    try {
        await ctx.answerCbQuery();
        const chatId = ctx.chat.id;
        const difficulty = ctx.match[1]; // easy, medium, or hard
        
        // Check if there's an active quiz in the correct state
        if (!activeQuizzes.has(chatId) || activeQuizzes.get(chatId).state !== QUIZ_STATE.SELECTING_DIFFICULTY) {
            return ctx.reply('‚ùå ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÖÿ≥ÿßÿ®ŸÇÿ© ŸÜÿ¥ÿ∑ÿ© ŸÅŸä ÿ≠ÿßŸÑÿ© ÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑÿµÿπŸàÿ®ÿ©.');
        }
        
        // Update quiz state with selected difficulty
        const quiz = activeQuizzes.get(chatId);
        quiz.difficulty = difficulty;
        quiz.state = QUIZ_STATE.SELECTING_QUESTION_COUNT;
        
        // Show question count selection keyboard
        const questionCountKeyboard = {
            inline_keyboard: [
                [
                    { text: '10', callback_data: 'count_10' },
                    { text: '25', callback_data: 'count_25' },
                    { text: '35', callback_data: 'count_35' }
                ],
                [
                    { text: '50', callback_data: 'count_50' },
                    { text: '75', callback_data: 'count_75' },
                    { text: '100', callback_data: 'count_100' }
                ],
                [{ text: 'üîô ÿßŸÑÿπŸàÿØÿ©', callback_data: 'back_to_quiz_menu' }]
            ]
        };
        
        const text = `ÿ™ŸÖ ÿßÿÆÿ™Ÿäÿßÿ± ŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑÿµÿπŸàÿ®ÿ©: ${difficulty}\n\nüî¢ ÿßÿÆÿ™ÿ± ÿπÿØÿØ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ŸÑŸÑŸÖÿ≥ÿßÿ®ŸÇÿ©:`;
        
        if (ctx.callbackQuery.message.photo) {
            await ctx.editMessageCaption(text, { reply_markup: questionCountKeyboard });
        } else {
            await ctx.editMessageText(text, { reply_markup: questionCountKeyboard });
        }
    } catch (error) {
        console.error('Error selecting difficulty:', error);
        await ctx.reply('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿßÿÆÿ™Ÿäÿßÿ± ŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑÿµÿπŸàÿ®ÿ©. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.');
    }
});
// Handle question count selection
// Handle question count selection
bot.action(/^count_(\d+)$/, async (ctx) => {
    try {
        await ctx.answerCbQuery();
        const chatId = ctx.chat.id;
        const count = parseInt(ctx.match[1]);

        console.log(`Received count selection: ${count} for chat ${chatId}`);

        if (!activeQuizzes.has(chatId)) {
            console.log(`No active quiz found for chat ${chatId}`);
            return ctx.reply('‚ùåü•≤  ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÖÿ≥ÿßÿ®ŸÇÿ© ŸÜÿ¥ÿ∑ÿ© ŸÅŸä Ÿáÿ∞Ÿá ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©. Ÿäÿ±ÿ¨Ÿâ ÿ®ÿØÿ° ŸÖÿ≥ÿßÿ®ŸÇÿ© ÿ¨ÿØŸäÿØÿ© ÿπŸÜ ÿ∑ÿ±ŸäŸÇ ÿßŸÑÿ±ÿ¨Ÿàÿπ ÿßŸÑŸâ ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ© ŸàÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿßÿÆÿ±Ÿâ.');
        }

        const quiz = activeQuizzes.get(chatId);
        console.log(`Quiz state for chat ${chatId}:`, quiz);

        if (quiz.state !== QUIZ_STATE.SELECTING_QUESTION_COUNT) {
            console.log(`Incorrect quiz state for chat ${chatId}: ${quiz.state}`);
            return ctx.reply(`‚ùå ÿßŸÑŸÖÿ≥ÿßÿ®ŸÇÿ© ŸÑŸäÿ≥ÿ™ ŸÅŸä ÿ≠ÿßŸÑÿ© ÿßÿÆÿ™Ÿäÿßÿ± ÿπÿØÿØ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ©. ÿßŸÑÿ≠ÿßŸÑÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ©: ${quiz.state}`);
        }

        // Handle custom difficulty
        if (quiz.difficulty === 'custom') {
            // Fetch custom questions from the database
            const customQuestions = await getCustomQuestionsForChat(chatId);
            
            if (customQuestions.length === 0) {
                console.log(`No custom questions available for chat ${chatId}`);
                activeQuizzes.delete(chatId);
                return ctx.reply('‚ùå ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ£ÿ≥ÿ¶ŸÑÿ© ŸÖÿÆÿµÿµÿ© ŸÖÿ™ÿßÿ≠ÿ©. Ÿäÿ±ÿ¨Ÿâ ÿ•ÿ∂ÿßŸÅÿ© ÿ£ÿ≥ÿ¶ŸÑÿ© ŸÖÿÆÿµÿµÿ© ÿ£ŸàŸÑÿßŸã.');
            }

            quiz.questions = customQuestions;
        } else {
            // Get questions for the selected difficulty
            let allQuestions = difficulties[quiz.difficulty] || [];
            
            if (allQuestions.length === 0) {
                console.log(`No questions available for difficulty ${quiz.difficulty}`);
                activeQuizzes.delete(chatId);
                return ctx.reply(`‚ùå ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ£ÿ≥ÿ¶ŸÑÿ© ŸÖÿ™ÿßÿ≠ÿ© ŸÑŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑÿµÿπŸàÿ®ÿ© "${quiz.difficulty}".`);
            }
            
            // If we don't have enough questions, we'll repeat some
            quiz.questions = [];
            while (quiz.questions.length < count) {
                const shuffled = shuffleArray(allQuestions);
                quiz.questions = [...quiz.questions, ...shuffled.slice(0, Math.min(count - quiz.questions.length, shuffled.length))];
            }
        }

        // Trim questions to the selected count
        quiz.questions = quiz.questions.slice(0, count);
        
        // Update quiz state and start
        quiz.state = QUIZ_STATE.ACTIVE;
        quiz.currentQuestionIndex = 0;
        quiz.scores = new Map();
        quiz.attempts = new Map();
        
        console.log(`Quiz started for chat ${chatId} with ${quiz.questions.length} questions`);
        
        await ctx.reply(`üéÆ ÿ™ŸÖ ÿ®ÿØÿ° ÿßŸÑŸÖÿ≥ÿßÿ®ŸÇÿ©! ÿ≥Ÿäÿ™ŸÖ ÿ∑ÿ±ÿ≠ ${count} ÿ≥ÿ§ÿßŸÑÿå ŸàŸÑÿØŸäŸÉ 30 ÿ´ÿßŸÜŸäÿ© ŸÑŸÑÿ•ÿ¨ÿßÿ®ÿ© ÿπŸÑŸâ ŸÉŸÑ ÿ≥ÿ§ÿßŸÑ.`);
        await ctx.reply('‚ö†Ô∏è ŸäŸÖŸÉŸÜŸÉ ÿ•ŸäŸÇÿßŸÅ ÿßŸÑŸÖÿ≥ÿßÿ®ŸÇÿ© ŸÅŸä ÿ£Ÿä ŸàŸÇÿ™ ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿ£ŸÖÿ± /stop');
        
        // Start the first question
        await askNextQuestion(chatId, ctx.telegram);

    } catch (error) {
        console.error('Error in count selection:', error);
        await ctx.reply('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ•ÿπÿØÿßÿØ ÿßŸÑŸÖÿ≥ÿßÿ®ŸÇÿ©. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.');
    }
});
// Add this function to fetch warning settings from the database
async function getWarningSettings(botId, chatId) {
    try {
        const db = await ensureDatabaseInitialized();
        const settings = await db.collection('warning_settings').findOne({ bot_id: botId, chat_id: chatId });
        return settings || {};
    } catch (error) {
        console.error('Error fetching warning settings:', error);
        return {};
    }
}

// Add this function to update warning settings in the database
async function updateWarningSettings(botId, chatId, settings) {
    try {
        const db = await ensureDatabaseInitialized();
        await db.collection('warning_settings').updateOne(
            { bot_id: botId, chat_id: chatId },
            { $set: settings },
            { upsert: true }
        );
    } catch (error) {
        console.error('Error updating warning settings:', error);
    }
}

// Add this function to fetch custom questions
async function getCustomQuestionsForChat(chatId) {
    try {
        const db = await database.getDb();
        const customQuestions = await db.collection('custom_questions').find({ chatId: chatId }).toArray();
        return customQuestions.map(q => ({ question: q.question, answer: q.answer }));
    } catch (error) {
        console.error('Error fetching custom questions:', error);
        return [];
    }
}
bot.action('change_bot_name', async (ctx) => {
    if (await isDeveloper(ctx, ctx.from.id)) {
        await ctx.answerCbQuery();
        await ctx.reply('ÿßŸÑÿ±ÿ¨ÿßÿ° ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿßÿ≥ŸÖ ÿßŸÑÿ¨ÿØŸäÿØ ŸÑŸÑÿ®Ÿàÿ™:');
        ctx.session.awaitingBotName = true;
    } else {
        await ctx.answerCbQuery('ÿπÿ∞ÿ±Ÿãÿßÿå Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ± ŸÑŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ ŸÅŸÇÿ∑', { show_alert: true });
    }
});
async function checkBotNameAndReply(ctx) {
    const chatId = ctx.chat.id;
    const messageText = ctx.message.text.toLowerCase();

    // Check if the chat is an active group
    if (!activeGroups.has(chatId)) {
        return;
    }

    try {
        const db = await ensureDatabaseInitialized();
        const botNameDoc = await db.collection('bot_names').findOne({ chat_id: chatId });

        if (botNameDoc && messageText.includes(botNameDoc.name.toLowerCase())) {
            const replies = [
                'ŸÜÿπŸÖÿå ÿ£ŸÜÿß ŸáŸÜÿß!',
                'ŸÖÿ±ÿ≠ÿ®Ÿãÿß! ŸÉŸäŸÅ ŸäŸÖŸÉŸÜŸÜŸä ŸÖÿ≥ÿßÿπÿØÿ™ŸÉÿü',
                'ŸáŸÑ ŸÜÿßÿØÿßŸÜŸä ÿ£ÿ≠ÿØÿü',
                'ŸÅŸä ÿÆÿØŸÖÿ™ŸÉ!'
            ];
            const randomReply = replies[Math.floor(Math.random() * replies.length)];
            await ctx.reply(randomReply, { reply_to_message_id: ctx.message.message_id });
        }
    } catch (error) {
        console.error('Error checking bot name:', error);
    }
} 
    
bot.action('show_current_bot_name', async (ctx) => {
    if (await isDeveloper(ctx, ctx.from.id)) {
        await ctx.answerCbQuery();
        const chatId = ctx.chat.id;
        try {
            const db = await ensureDatabaseInitialized();
            const botName = await db.collection('bot_names').findOne({ chat_id: chatId });
            if (botName) {
                await ctx.reply(`ÿßŸáŸÑÿß ÿ®ŸÉ ÿπÿ≤Ÿäÿ≤Ÿä ŸÅŸä ŸÇÿ≥ŸÖ ÿßÿ≥ŸÖ ÿßŸÑÿ®Ÿàÿ™\nÿßÿ≥ŸÖ ÿßŸÑÿ®Ÿàÿ™ ÿßŸÑÿ¢ŸÜ: ${botName.name}`);
            } else {
                await ctx.reply('ŸÑŸÖ Ÿäÿ™ŸÖ ÿ™ÿπŸäŸäŸÜ ÿßÿ≥ŸÖ ŸÖÿÆÿµÿµ ŸÑŸÑÿ®Ÿàÿ™ ŸÅŸä Ÿáÿ∞Ÿá ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ©.');
            }
        } catch (error) {
            console.error('Error fetching bot name:', error);
            await ctx.reply('ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ŸÖÿ≠ÿßŸàŸÑÿ© ÿπÿ±ÿ∂ ÿßÿ≥ŸÖ ÿßŸÑÿ®Ÿàÿ™.');
        }
    } else {
        await ctx.answerCbQuery('ÿπÿ∞ÿ±Ÿãÿßÿå Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ± ŸÑŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ ŸÅŸÇÿ∑', { show_alert: true });
    }
});
    bot.command('update_groups', async (ctx) => {
        if (await isDeveloper(ctx, ctx.from.id)) {
            updateActiveGroups(ctx);
            ctx.reply(`Groups updated. Current count: ${activeGroups.size}`);
        }
    });
    bot.command('debug_groups', async (ctx) => {
        if (await isDeveloper(ctx, ctx.from.id)) {
            let debugMessage = `Active Groups (${activeGroups.size}):\n\n`;
            for (const [groupId, groupInfo] of activeGroups) {
                debugMessage += `${groupInfo.title} (${groupId})\n`;
            }
            ctx.reply(debugMessage);
        }
    });
   


    bot.command('ÿ™ŸÜÿ≤ŸäŸÑ ŸÖÿ∑Ÿàÿ±', async (ctx) => {
        await demoteUser(ctx, 'developer');
    });
    
    bot.hears(/^ÿ™ŸÜÿ≤ŸäŸÑ ŸÖÿ∑Ÿàÿ±/, async (ctx) => {
        await demoteUser(ctx, 'developer');
    });
    // Add these lines to your existing command handlers
bot.hears(/^ÿ™ÿ±ŸÇŸäÿ© (ŸÖŸÖŸäÿ≤|ÿßÿØŸÖŸÜ|ŸÖÿØŸäÿ±|ŸÖŸÜÿ¥ÿ¶|ŸÖŸÜÿ¥ÿ¶ ÿßÿ≥ÿßÿ≥Ÿä|ŸÖÿ∑Ÿàÿ±|ŸÖÿ∑Ÿàÿ± ÿ´ÿßŸÜŸàŸä)/, (ctx) => {
    const role = ctx.match[1];
    promoteUser(ctx, role);
});

bot.hears('ÿ™ŸÜÿ≤ŸäŸÑ', (ctx) => demoteUser(ctx));


bot.on('left_chat_member', (ctx) => {
    if (ctx.message.left_chat_member.id === ctx.botInfo.id) {
        markGroupAsInactive(ctx.chat.id);
    }
});    
bot.on(['photo', 'document', 'animation', 'sticker'], async (ctx) => {
    const userId = ctx.from.id;
    const state = pendingReplies.get(userId);

    if (!state || state.step !== 'awaiting_response') return;

    const db = await ensureDatabaseInitialized();

    let mediaType = 'unknown';
    let fileId;
    let extension = 'bin';

    if (ctx.message.photo) {
        mediaType = 'photo';
        fileId = ctx.message.photo.at(-1).file_id;
        extension = 'jpg';
    } else if (ctx.message.wewe) {
        mediaType = 'wewe';
        fileId = ctx.message.video.file_id;
        extension = 'mp4';
    } else if (ctx.message.document) {
        mediaType = 'document';
        fileId = ctx.message.document.file_id;
        extension = ctx.message.document.file_name?.split('.').pop() || 'file';
    } else if (ctx.message.animation) {
        mediaType = 'animation';
        fileId = ctx.message.animation.file_id;
        extension = 'mp4';
    } else if (ctx.message.sticker) {
        mediaType = 'sticker';
        fileId = ctx.message.sticker.file_id;
        extension = 'webp';
    }

    const fileLink = await ctx.telegram.getFileLink(fileId);
    const fileName = `${mediaType}_${Date.now()}_${userId}.${extension}`;
    const savedFilePath = await saveFile(fileLink, fileName);

    await db.collection('replies').insertOne({
        bot_id: state.botId,
        trigger_word: state.triggerWord,
        type: 'media',
        media_type: mediaType,
        file_id: fileId,
        file_path: savedFilePath,
        created_by: userId,
        created_at: new Date()
    });

    await ctx.reply(`‚úÖ ÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿßŸÑÿ±ÿØ (${mediaType}) ŸÑŸÑŸÉŸÑŸÖÿ© "${state.triggerWord}"`);
    pendingReplies.delete(userId);
});




// Register the text handler
    // For the text handler that's causing errors, update it to:
    // Register the text handler
    bot.on('text', async (ctx) => {
        const userId = ctx.from.id;
        const chatId = ctx.chat.id; // üëà Fix added here
        const userState = pendingReplies.get(userId);
        const text = ctx.message.text?.trim();
        const isBroadcasting = chatBroadcastStates.get(chatId) || awaitingBroadcastPhoto;
        const userAnswer = ctx.message.text.trim().toLowerCase();
        if (ctx.session.awaitingBotName) {
            const newBotName = ctx.message.text.trim();
            const chatId = ctx.chat.id;
            try {
                const db = await ensureDatabaseInitialized();
                await db.collection('bot_names').updateOne(
                    { chat_id: chatId },
                    { $set: { name: newBotName } },
                    { upsert: true }
                );
    
                // Save a default reply for the new bot name
                await db.collection('replies').updateOne(
                    { trigger_word: newBotName, chat_id: chatId },
                    { $set: { 
                        trigger_word: newBotName, 
                        reply_text: `ÿπŸäŸàŸÜŸá üôå: ${newBotName}`,
                        chat_id: chatId,
                        type: "text"
                    }},
                    { upsert: true }
                );
    
                await ctx.reply(`‚úÖ ÿ™ŸÖ ÿ™ÿ∫ŸäŸäÿ± ÿßÿ≥ŸÖ ÿßŸÑÿ®Ÿàÿ™ ÿ•ŸÑŸâ "${newBotName}" Ÿàÿ≠ŸÅÿ∏ ÿßŸÑÿ±ÿØ ÿßŸÑÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä.`);
                ctx.session.awaitingBotName = false;
            } catch (error) {
                console.error('Error updating bot name:', error);
                await ctx.reply('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ™ÿ≠ÿØŸäÿ´ ÿßÿ≥ŸÖ ÿßŸÑÿ®Ÿàÿ™. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.');
                ctx.session.awaitingBotName = false;
            }
        }
         if (!state) return;

    
    if (isNaN(count) || count < 1) {
        return ctx.reply('‚ùå Ÿäÿ±ÿ¨Ÿâ ÿ•ÿØÿÆÿßŸÑ ÿ±ŸÇŸÖ ÿµÿ≠Ÿäÿ≠ ÿ£ŸÉÿ®ÿ± ŸÖŸÜ 0.');
    }

    let updateField;
    switch (action) {
        case 'edit_warning_kick':
            updateField = { kick: count };
            break;
        case 'edit_warning_mute':
            updateField = { mute: count };
            break;
        case 'edit_warning_restrict_media':
            updateField = { restrictMedia: count };
            break;
        default:
            return;
    }

    await updateWarningSettings(botId, chatId, updateField);
    await ctx.reply('‚úÖ ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™ ÿ®ŸÜÿ¨ÿßÿ≠.');
    userStates.delete(userId);
return;
    
    

if (isBroadcasting && text) {
    try {
        await broadcastMessage(ctx, null, null, text);

        if (awaitingBroadcastPhoto) {
            awaitingBroadcastPhoto = false;
            await ctx.reply('‚úÖ ÿ™ŸÖ ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©.\nüõë ÿ™ŸÖ ÿ•ŸäŸÇÿßŸÅ Ÿàÿ∂ÿπ ÿßŸÑÿ•ÿ∞ÿßÿπÿ© ÿßŸÑŸäÿØŸàŸä.');
        }

        return; // üõë Prevent further processing of this broadcast message
    } catch (error) {
        console.error('Error broadcasting text:', error);
        await ctx.reply('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ®ÿ´ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©.');
        return;
    }
}


    if (userState) {
        if (userState.step === 'awaiting_trigger') {
            userState.triggerWord = text;
            userState.step = 'awaiting_response';
            await ctx.reply(`ÿ™ŸÖ ÿßÿ≥ÿ™ŸÑÿßŸÖ ÿßŸÑŸÉŸÑŸÖÿ© "${text}". ÿßŸÑÿ¢ŸÜ ÿ£ÿ±ÿ≥ŸÑ ÿßŸÑÿ±ÿØ (ŸÜÿµ ÿ£Ÿà Ÿàÿ≥ÿßÿ¶ÿ∑):`);
            return;
        }
        const db = await ensureDatabaseInitialized();
        const trigger = text.toLowerCase();
        const reply = await db.collection('replies').findOne({ trigger_word: trigger });
        if (userState.step === 'awaiting_response') {
            const db = await ensureDatabaseInitialized();
            await db.collection('replies').insertOne({
                bot_id: userState.botId,
                trigger_word: userState.triggerWord,
                type: 'text',
                text: text,
                created_by: userId,
                created_at: new Date()
            });

            await ctx.reply(`‚úÖ ÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿßŸÑÿ±ÿØ ÿßŸÑŸÜÿµŸä ŸÑŸÑŸÉŸÑŸÖÿ© "${userState.triggerWord}"`);
            pendingReplies.delete(userId);
            return;
        }
    }
        try {
            console.log('Received message:', ctx.message.text);
            
            // First, handle any awaiting states
            if (await handleAwaitingReplyResponse(ctx)) return;
            
            const text = ctx.message.text.trim().toLowerCase();
            const chatId = ctx.chat.id;
            const userId = ctx.from.id;
            
            // Handle awaiting states in private chats
            if (ctx.chat.type === 'private') {
                if (awaitingReplyWord) {
                    tempReplyWord = text;
                    ctx.reply(`ÿ™ŸÖ ÿßÿ≥ÿ™ŸÑÿßŸÖ ÿßŸÑŸÉŸÑŸÖÿ©: "${tempReplyWord}". ÿßŸÑÿ¢ŸÜ ÿ£ÿ±ÿ≥ŸÑ ÿßŸÑÿ±ÿØ ÿßŸÑÿ∞Ÿä ÿ™ÿ±ŸäÿØ ÿ•ÿ∂ÿßŸÅÿ™Ÿá ŸÑŸáÿ∞Ÿá ÿßŸÑŸÉŸÑŸÖÿ©:`);
                    awaitingReplyWord = false;
                    awaitingReplyResponse = true;
                    return;
                } else if (awaitingReplyResponse) {
                    const replyResponse = ctx.message.text;
                    try {
                        const db = await ensureDatabaseInitialized();
                        const botId = ctx.botInfo.id; // Get current bot ID
                        
                        await db.collection('replies').updateOne(
                            { trigger_word: tempReplyWord, bot_id: botId },
                            { $set: { 
                                trigger_word: tempReplyWord, 
                                reply_text: replyResponse,
                                bot_id: botId,
                                type: "text"
                            }},
                            { upsert: true }
                        );
                        
                        ctx.reply(`ÿ™ŸÖ ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ±ÿØ ÿ®ŸÜÿ¨ÿßÿ≠!\nÿßŸÑŸÉŸÑŸÖÿ©: ${tempReplyWord}\nÿßŸÑÿ±ÿØ: ${replyResponse}`);
                        awaitingReplyResponse = false;
                        return;
                    } catch (error) {
                        console.error('Error saving reply:', error);
                        ctx.reply('ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ≠ŸÅÿ∏ ÿßŸÑÿ±ÿØ. ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.');
                        awaitingReplyResponse = false;
                        return;
                    }
                } else if (awaitingDeleteReplyWord) {
                    try {
                        const db = await ensureDatabaseInitialized();
                        const botId = ctx.botInfo.id;
                        
                        const result = await db.collection('replies').deleteOne({ 
                            trigger_word: text,
                            bot_id: botId
                        });
                        
                        if (result.deletedCount > 0) {
                            ctx.reply(`ÿ™ŸÖ ÿ≠ÿ∞ŸÅ ÿßŸÑÿ±ÿØ ŸÑŸÑŸÉŸÑŸÖÿ© "${text}" ÿ®ŸÜÿ¨ÿßÿ≠.`);
                        } else {
                            // Try to delete global reply if bot-specific not found
                            const globalResult = await db.collection('replies').deleteOne({ 
                                trigger_word: text,
                                bot_id: { $exists: false }
                            });
                            
                            if (globalResult.deletedCount > 0) {
                                ctx.reply(`ÿ™ŸÖ ÿ≠ÿ∞ŸÅ ÿßŸÑÿ±ÿØ ÿßŸÑÿπÿßŸÖ ŸÑŸÑŸÉŸÑŸÖÿ© "${text}" ÿ®ŸÜÿ¨ÿßÿ≠.`);
                            } else {
                                ctx.reply(`ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿ±ÿØ ŸÑŸÑŸÉŸÑŸÖÿ© "${text}".`);
                            }
                        }
                        awaitingDeleteReplyWord = false;
                        return;
                    } catch (error) {
                        console.error('Error deleting reply:', error);
                        ctx.reply('ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ≠ÿ∞ŸÅ ÿßŸÑÿ±ÿØ. ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.');
                        awaitingDeleteReplyWord = false;
                        return;
                    }
                } else if (awaitingBotName) {
                    try {
                        await ctx.telegram.setMyName(text);
                        ctx.reply(`ÿ™ŸÖ ÿ™ÿ∫ŸäŸäÿ± ÿßÿ≥ŸÖ ÿßŸÑÿ®Ÿàÿ™ ÿ®ŸÜÿ¨ÿßÿ≠ ÿ•ŸÑŸâ: ${text}`);
                        awaitingBotName = false;
                        return;
                    } catch (error) {
                        console.error('Error changing bot name:', error);
                        ctx.reply('ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ™ÿ∫ŸäŸäÿ± ÿßÿ≥ŸÖ ÿßŸÑÿ®Ÿàÿ™. ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.');
                        awaitingBotName = false;
                        return;
                    }
                }
                
                // Handle user states for adding replies
                const userState = userStates.get(userId);
                if (userState) {
                    if (userState.action === 'adding_reply' && userState.step === 'awaiting_trigger') {
                        userState.trigger = text;
                        userState.step = 'awaiting_response';
                        userStates.set(userId, userState);
                        
                        await ctx.reply(`ÿ™ŸÖ ÿßÿ≥ÿ™ŸÑÿßŸÖ ÿßŸÑŸÉŸÑŸÖÿ©: "${text}". ÿßŸÑÿ¢ŸÜ ÿ£ÿ±ÿ≥ŸÑ ÿßŸÑÿ±ÿØ ÿßŸÑÿ∞Ÿä ÿ™ÿ±ŸäÿØ ÿ•ÿ∂ÿßŸÅÿ™Ÿá ŸÑŸáÿ∞Ÿá ÿßŸÑŸÉŸÑŸÖÿ©:`, {
                            reply_markup: {
                                inline_keyboard: [[{ text: 'ÿ•ŸÑÿ∫ÿßÿ°', callback_data: 'cancel_add_reply' }]]
                            }
                        });
                        return;
                    } else if (userState.action === 'adding_reply' && userState.step === 'awaiting_response') {
                        const replyText = text;
                        const triggerWord = userState.trigger;
                        const botId = userState.botId || ctx.botInfo.id;
                        
                        try {
                            const db = await ensureDatabaseInitialized(botId);
                            await db.collection('replies').updateOne(
                                { trigger_word: triggerWord, bot_id: botId },
                                { $set: { 
                                    trigger_word: triggerWord, 
                                    reply_text: replyText,
                                    bot_id: botId,
                                    type: "text"
                                }},
                                { upsert: true }
                            );
                            
                            await ctx.reply(`‚úÖ ÿ™ŸÖ ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ±ÿØ ÿ®ŸÜÿ¨ÿßÿ≠!\n\nÿßŸÑŸÉŸÑŸÖÿ©: ${triggerWord}\nÿßŸÑÿ±ÿØ: ${replyText}`);
                            userStates.delete(userId);
                        } catch (error) {
                            console.error('Error saving reply:', error);
                            await ctx.reply('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ≠ŸÅÿ∏ ÿßŸÑÿ±ÿØ. ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.');
                        }
                        return;
                    }
                }
            }
            
            // Check for automatic replies
            try {
                const db = await ensureDatabaseInitialized();
                console.log('Searching for reply with keyword:', text);
                
                // First try to find a bot-specific reply
                const botId = ctx.botInfo.id; // Get the current bot's ID
                let reply = await db.collection('replies').findOne({
                    bot_id: botId,
                    $or: [
                        { trigger_word: text },
                        { word: text }
                    ]
                });
                
                // If no bot-specific reply is found, try to find a global reply
                if (!reply) {
                    reply = await db.collection('replies').findOne({
                        $or: [
                            { trigger_word: text },
                            { word: text }
                        ],
                        bot_id: { $exists: false }
                    });
                }
                
                console.log('Reply search result:', reply);
                
                if (reply) {
                    // Handle different reply structures
                    if (reply.reply_text) {
                        await ctx.reply(reply.reply_text, { reply_to_message_id: ctx.message.message_id });
                        return;
                    }
                    
                    // Handle typed replies
if (reply) {
    try {
        switch (reply.type) {
            case "text":
                if (reply.text || reply.reply_text) {
                    await ctx.reply(reply.text || reply.reply_text, { reply_to_message_id: ctx.message.message_id });
                } else {
                    throw new Error('No valid text content found in reply');
                }
                break;
            case "photo":
                if (reply.file_id) {
                    await ctx.replyWithPhoto(reply.file_id, { reply_to_message_id: ctx.message.message_id });
                } else {
                    throw new Error('No valid photo file_id found in reply');
                }
                break;
            // ‚úÖ Add this case to handle 'media' replies
            case "media":
                if (!reply.media_type) {
                    throw new Error('Missing media_type in media reply');
                }
        
                switch (reply.media_type) {
                    case "photo":
                        await ctx.replyWithPhoto(reply.file_id, { reply_to_message_id: ctx.message.message_id });
                        break;
                    case "video":
                        await ctx.replyWithVideo(reply.file_id, { reply_to_message_id: ctx.message.message_id });
                        break;
                    case "animation":
                        await ctx.replyWithAnimation(reply.file_id, { reply_to_message_id: ctx.message.message_id });
                        break;
                    case "document":
                        await ctx.replyWithDocument(reply.file_id, { reply_to_message_id: ctx.message.message_id });
                        break;
                    case "sticker":
                        await ctx.replyWithSticker(reply.file_id, { reply_to_message_id: ctx.message.message_id });
                        break;
                    default:
                        throw new Error(`Unsupported media_type: ${reply.media_type}`);
                }
                break;
            case "animation":
            case "video":
            case "sticker":
            case "document":
                if (reply.file_id) {
                    const method = {
                        animation: ctx.replyWithAnimation,
                        video: ctx.replyWithVideo,
                        sticker: ctx.replyWithSticker,
                        document: ctx.replyWithDocument
                    }[reply.type];
                    await method.call(ctx, reply.file_id, { reply_to_message_id: ctx.message.message_id });
                } else {
                    throw new Error(`No valid ${reply.type} file_id found in reply`);
                }
                break;
            default:
                // If nothing matched and we still have some text, send it
                if (reply.text || reply.reply_text) {
                    await ctx.reply(reply.text || reply.reply_text, { reply_to_message_id: ctx.message.message_id });
                } else {
                    throw new Error('No valid content found in reply');
                }
        }
        

    } catch (error) {
        console.error('Error handling reply:', error.message);
        console.error('Reply object:', JSON.stringify(reply, null, 2));
        await ctx.reply('ÿπÿ∞ÿ±Ÿãÿßÿå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑÿ±ÿØ. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ÿ£Ÿà ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ŸÖÿ≥ÿ§ŸàŸÑ ÿßŸÑŸÜÿ∏ÿßŸÖ.');
    }
} else {
    console.log('No reply found for the given trigger');
}
                    return;
                }
            } catch (error) {
                console.error('Error checking for automatic replies:', error);
            }
            
            // Handle quiz answers if there's an active quiz
            if (activeQuizzes.has(chatId) && activeQuizzes.get(chatId).state === QUIZ_STATE.ACTIVE) {
                await handleQuizAnswer(ctx);
                return;
            }
            
            // Update last interaction for the user
            updateLastInteraction(userId);
            
            // If in a group, update the group's active status
            if (ctx.chat.type === 'group' || ctx.chat.type === 'supergroup') {
                updateActiveGroups(ctx);
            }
            
        } catch (error) {
            console.error('Error in text handler:', error);
        }
         // Check if there's an active quiz in this chat
        if (!activeQuizzes.has(chatId) || activeQuizzes.get(chatId).state !== QUIZ_STATE.ACTIVE) {
            return; // No active quiz, so continue with other handlers
        }
        
        const quiz = activeQuizzes.get(chatId);
        const currentQuestion = quiz.questions[quiz.currentQuestionIndex];
        
        if (!currentQuestion) {
            return; // No current question
        }
        
        // Check if this user has already attempted this question
        if (quiz.attempts.has(`${userId}_${quiz.currentQuestionIndex}`)) {
            return; // User already attempted this question
        }
        
        // Mark that this user has attempted this question
        quiz.attempts.set(`${userId}_${quiz.currentQuestionIndex}`, true);
        
        // Check if the answer is correct (case insensitive comparison)
        const correctAnswer = currentQuestion.answer.toLowerCase();
        const isCorrect = userAnswer === correctAnswer;
        
        if (isCorrect) {
            // Update user's score
            const currentScore = quiz.scores.get(userId) || 0;
            quiz.scores.set(userId, currentScore + 1);
            
            // Get user info for the leaderboard
            const firstName = ctx.from.first_name || '';
            const lastName = ctx.from.last_name || '';
            const username = ctx.from.username || '';
            
            // Save the score to the database
            try {
                await database.saveQuizScore(chatId, userId, firstName, lastName, username, 1);
            } catch (dbError) {
                console.error('Error saving quiz score:', dbError);
            }
            
            // Clear any pending timeouts for this question
            while (quiz.timeouts.length) {
                clearTimeout(quiz.timeouts.pop());
            }
            
            // Send congratulatory message
            await ctx.reply(`üéâ ÿ•ÿ¨ÿßÿ®ÿ© ÿµÿ≠Ÿäÿ≠ÿ© ŸÖŸÜ ${firstName}! (+1 ŸÜŸÇÿ∑ÿ©)`);
            
            // Move to the next question
            quiz.currentQuestionIndex++;
            
            // Check if we've reached the end of the quiz
            if (quiz.currentQuestionIndex >= quiz.questions.length) {
                await endQuiz(ctx, chatId);
            } else {
                // Ask the next question after a short delay
                setTimeout(() => askNextQuestion(chatId, ctx.telegram), 2000);
            }
        }
    });



// Updated handleMediaReply function to check both global and user-specific states


// Helper function to get Arabic names for media types
// Add this helper function
function getMediaTypeInArabic(mediaType) {
    switch (mediaType) {
        case 'photo':
            return 'ÿµŸàÿ±ÿ©';
        case 'video':
            return 'ŸÅŸäÿØŸäŸà';
        case 'animation':
            return 'ÿµŸàÿ±ÿ© ŸÖÿ™ÿ≠ÿ±ŸÉÿ©';
        case 'document':
            return 'ŸÖŸÑŸÅ';
        case 'sticker':
            return 'ŸÖŸÑÿµŸÇ';
        default:
            return mediaType;
    }
}

    //this fucks how the bot starts
     // Replace the problematic message handler with this one
     
    bot.on('message', async (ctx, next) => {
        await updateGroupInfo(ctx);
    next();
    try {
        console.log('Received message:', ctx.message);

        const userId = ctx.from.id;
        const username = ctx.from.username;
        const message = ctx.message;
        const chatId = ctx.chat.id;

        // Update last interaction for the user
        updateLastInteraction(userId, username, ctx.from.first_name, ctx.from.last_name);
        
        // If in a group, update the group's active status
        if (ctx.chat.type === 'group' || ctx.chat.type === 'supergroup') {
            updateActiveGroups(ctx.chat.id, ctx.chat.title);
        }

        // Handle custom question input for quizzes
        if (chatStates.has(chatId)) {
            await handleCustomQuestionInput(ctx);
            return;
        }
 // Handle broadcast command or media
if ((message.text && message.text.startsWith('ÿßÿ∞ÿßÿπÿ©')) || 
(message.caption && message.caption.startsWith('ÿßÿ∞ÿßÿπÿ©')) || 
(ctx.message.reply_to_message && ctx.message.reply_to_message.text === 'ÿßÿ∞ÿßÿπÿ©')) {
if (await isDeveloper(ctx, userId)) {
    await handleBroadcast(ctx);
    return;
}
}
        // Handle photos
                // Handle photos
        if (ctx.message.photo && awaitingReplyResponse) {
            const fileId = ctx.message.photo[ctx.message.photo.length - 1].file_id;
            try {
                const db = await ensureDatabaseInitialized();
                await db.collection('replies').insertOne({
                    trigger_word: tempReplyWord,
                    type: 'photo',
                    file_id: fileId,
                    created_at: new Date(),
                    created_by: ctx.from.id
                });
                await ctx.reply(`‚úÖ ÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿßŸÑÿµŸàÿ±ÿ© ŸÉÿ±ÿØ ŸÑŸÑŸÉŸÑŸÖÿ© "${tempReplyWord}" ÿ®ŸÜÿ¨ÿßÿ≠.`);
                // Reset the state
                awaitingReplyResponse = false;
                tempReplyWord = '';
            } catch (error) {
                console.error('Error saving photo reply:', error);
                await ctx.reply('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ≠ŸÅÿ∏ ÿßŸÑÿµŸàÿ±ÿ© ŸÉÿ±ÿØ. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.');
            }
            return;
        } else if (ctx.message.photo) {
            // If a photo is received but we're not awaiting a reply, ignore it
            return;
        }

        // Handle animations (GIFs)
                // Handle animations (GIFs)
        if (ctx.message.animation && awaitingReplyResponse) {
            const fileId = ctx.message.animation.file_id;
            try {
                const db = await ensureDatabaseInitialized();
                await db.collection('replies').insertOne({
                    trigger_word: tempReplyWord,
                    type: 'animation',
                    file_id: fileId,
                    created_at: new Date(),
                    created_by: ctx.from.id
                });
                await ctx.reply(`‚úÖ ÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿßŸÑŸÄ GIF ŸÉÿ±ÿØ ŸÑŸÑŸÉŸÑŸÖÿ© "${tempReplyWord}" ÿ®ŸÜÿ¨ÿßÿ≠.`);
                // Reset the state
                awaitingReplyResponse = false;
                tempReplyWord = '';
            } catch (error) {
                console.error('Error saving GIF reply:', error);
                await ctx.reply('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ≠ŸÅÿ∏ ÿßŸÑŸÄ GIF ŸÉÿ±ÿØ. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.');
            }
            return;
        } else if (ctx.message.animation) {
            // If a GIF is received but we're not awaiting a reply, ignore it
            return;
        }

        // Handle documents (like MP4 or other media)
                // Handle documents (like MP4 or other media)
        if (ctx.message.document && awaitingReplyResponse) {
            const fileId = ctx.message.document.file_id;
            try {
                const db = await ensureDatabaseInitialized();
                await db.collection('replies').insertOne({
                    trigger_word: tempReplyWord,
                    type: 'document',
                    file_id: fileId,
                    file_name: ctx.message.document.file_name,
                    mime_type: ctx.message.document.mime_type,
                    created_at: new Date(),
                    created_by: ctx.from.id
                });
                await ctx.reply(`‚úÖ ÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿßŸÑŸÖÿ≥ÿ™ŸÜÿØ ŸÉÿ±ÿØ ŸÑŸÑŸÉŸÑŸÖÿ© "${tempReplyWord}" ÿ®ŸÜÿ¨ÿßÿ≠.`);
                // Reset the state
                awaitingReplyResponse = false;
                tempReplyWord = '';
            } catch (error) {
                console.error('Error saving document reply:', error);
                await ctx.reply('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ≠ŸÅÿ∏ ÿßŸÑŸÖÿ≥ÿ™ŸÜÿØ ŸÉÿ±ÿØ. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.');
            }
            return;
        } else if (ctx.message.document) {
            // If a document is received but we're not awaiting a reply, ignore it
            return;
        }

        // Handle stickers
                // Handle stickers
        if (ctx.message.sticker && awaitingReplyResponse) {
            const fileId = ctx.message.sticker.file_id;
            try {
                const db = await ensureDatabaseInitialized();
                await db.collection('replies').insertOne({
                    trigger_word: tempReplyWord,
                    type: 'sticker',
                    file_id: fileId,
                    created_at: new Date(),
                    created_by: ctx.from.id
                });
                await ctx.reply(`‚úÖ ÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿßŸÑŸÖŸÑÿµŸÇ ŸÉÿ±ÿØ ŸÑŸÑŸÉŸÑŸÖÿ© "${tempReplyWord}" ÿ®ŸÜÿ¨ÿßÿ≠.`);
                // Reset the state
                awaitingReplyResponse = false;
                tempReplyWord = '';
            } catch (error) {
                console.error('Error saving sticker reply:', error);
                await ctx.reply('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ≠ŸÅÿ∏ ÿßŸÑŸÖŸÑÿµŸÇ ŸÉÿ±ÿØ. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.');
            }
            return;
        } else if (ctx.message.sticker) {
            // If a sticker is received but we're not awaiting a reply, ignore it
            return;
        }

               // Handle videos
        if (ctx.message.video && awaitingReplyResponse) {
            const fileId = ctx.message.video.file_id;
            try {
                const db = await ensureDatabaseInitialized();
                await db.collection('replies').insertOne({
                    trigger_word: tempReplyWord,
                    type: 'video',
                    file_id: fileId,
                    duration: ctx.message.video.duration,
                    width: ctx.message.video.width,
                    height: ctx.message.video.height,
                    mime_type: ctx.message.video.mime_type,
                    created_at: new Date(),
                    created_by: ctx.from.id
                });
                await ctx.reply(`‚úÖ ÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿßŸÑŸÅŸäÿØŸäŸà ŸÉÿ±ÿØ ŸÑŸÑŸÉŸÑŸÖÿ© "${tempReplyWord}" ÿ®ŸÜÿ¨ÿßÿ≠.`);
                // Reset the state
                awaitingReplyResponse = false;
                tempReplyWord = '';
            } catch (error) {
                console.error('Error saving video reply:', error);
                await ctx.reply('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ≠ŸÅÿ∏ ÿßŸÑŸÅŸäÿØŸäŸà ŸÉÿ±ÿØ. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.');
            }
            return;
        } else if (ctx.message.video) {
            // If a video is received but we're not awaiting a reply, ignore it
            return;
        }

        // Handle text messages
        if (message.text) {
            await handleTextMessage(ctx);
            return;
        }

        // If we reach here, it's an unsupported message type
        await ctx.reply('');

    } catch (error) {
        console.error('Error in message handler:', error);
        await ctx.reply('');
    }

    await next();
});

async function handleTextMessage(ctx) {
    const chatId = ctx.chat.id;
    const userId = ctx.from.id;
    const userAnswer = ctx.message.text.trim().toLowerCase();

    // Check for active quiz
    if (activeQuizzes.has(chatId)) {
        await handleQuizAnswer(ctx, chatId, userId, userAnswer);
        return;
    }

    // Check for automatic replies
    // ‚úÖ Only scan replies in private chats
if (ctx.chat.type === 'private') {
    const reply = await checkForAutomaticReply(ctx);
    if (reply) {
        await sendReply(ctx, reply);
        return;
    }
}

// Add this function to handle awaiting reply word
async function handleAwaitingReplyWord(ctx) {
    tempReplyWord = ctx.message.text.trim().toLowerCase();
    await ctx.reply(`ÿ™ŸÖ ÿßÿ≥ÿ™ŸÑÿßŸÖ ÿßŸÑŸÉŸÑŸÖÿ©: "${tempReplyWord}". ÿßŸÑÿ¢ŸÜ ÿ£ÿ±ÿ≥ŸÑ ÿßŸÑÿ±ÿØ ÿßŸÑÿ∞Ÿä ÿ™ÿ±ŸäÿØ ÿ•ÿ∂ÿßŸÅÿ™Ÿá ŸÑŸáÿ∞Ÿá ÿßŸÑŸÉŸÑŸÖÿ© (ŸÜÿµÿå ÿµŸàÿ±ÿ©ÿå ŸÅŸäÿØŸäŸàÿå ŸÖŸÑÿµŸÇÿå GIFÿå ÿ£Ÿà ŸÖÿ≥ÿ™ŸÜÿØ):`);
    awaitingReplyWord = false;
    awaitingReplyResponse = true;
    return true;
}

// Add this function to handle awaiting text reply response
async function handleAwaitingReplyResponse(ctx) {
    const text = ctx.message.text.trim();
    try {
        const db = await ensureDatabaseInitialized();
        await db.collection('replies').insertOne({
            trigger_word: tempReplyWord,
            word: tempReplyWord,
            type: 'text',
            text: text,
            reply_text: text,
            created_at: new Date(),
            created_by: ctx.from.id,
            username: ctx.from.username
        });
        
        await ctx.reply(`‚úÖ ÿ™ŸÖ ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ±ÿØ ÿßŸÑŸÜÿµŸä ÿ®ŸÜÿ¨ÿßÿ≠!\nÿßŸÑŸÉŸÑŸÖÿ©: ${tempReplyWord}\nÿßŸÑÿ±ÿØ: ${text}`);
        
        // Reset the state
        awaitingReplyResponse = false;
        tempReplyWord = '';
        
        return true;
    } catch (error) {
        console.error('Error saving text reply:', error);
        await ctx.reply('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ≠ŸÅÿ∏ ÿßŸÑÿ±ÿØ. ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.');
        
        // Reset the state
        awaitingReplyResponse = false;
        tempReplyWord = '';
        
        return true;
    }
}
    // Handle awaiting reply word
    if (awaitingReplyWord) {
        await handleAwaitingReplyWord(ctx);
        return;
    }

    // Handle awaiting delete reply word
    if (awaitingDeleteReplyWord) {
        await handleAwaitingDeleteReplyWord(ctx);
        return;
    }

    // Handle awaiting bot name
    if (awaitingBotName) {
        await handleAwaitingBotName(ctx);
        return;
    }

    // Handle awaiting reply response
    if (awaitingReplyResponse) {
        await handleAwaitingReplyResponse(ctx);
        return;
    }

    // If we reach here, it's an unhandled text message
    await ctx.reply('ÿπÿ∞ÿ±Ÿãÿßÿå ŸÑŸÖ ÿ£ŸÅŸáŸÖ Ÿáÿ∞Ÿá ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©. ŸáŸÑ ŸäŸÖŸÉŸÜŸÉ ÿ™Ÿàÿ∂Ÿäÿ≠ ÿ∑ŸÑÿ®ŸÉÿü');
}
// Replace your existing video handler with this one
bot.on('video', async (ctx) => {
    try {
        const chatId = ctx.chat.id;
        const isRestricted = videoRestrictionStatus.get(chatId);

        // Check if this is a reply to a trigger word
        if (await handleMediaReply(ctx, 'video')) {
            return; // Media was handled as a reply
        }

        // Continue with restriction check
        if (isRestricted) {
            const chatMember = await ctx.telegram.getChatMember(chatId, ctx.from.id);
            
            if (chatMember.status !== 'administrator' && chatMember.status !== 'creator') {
                await ctx.deleteMessage();
                await ctx.reply('‚ùå ÿπÿ∞ÿ±Ÿãÿßÿå ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑŸÅŸäÿØŸäŸàŸáÿßÿ™ ÿ∫Ÿäÿ± ŸÖÿ≥ŸÖŸàÿ≠ ÿ≠ÿßŸÑŸäŸãÿß ŸÑŸÑÿ£ÿπÿ∂ÿßÿ° ÿßŸÑÿπÿßÿØŸäŸäŸÜ ŸÅŸä Ÿáÿ∞Ÿá ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ©.');
                return;
            }
        }

        // Continue with any existing video handling logic...
    } catch (error) {
        console.error('Error handling video message:', error);
    }
});

// Replace your existing photo handler with this one
// Clean up duplicate handlers and use the consolidated function
// Photo handler
// Consolidated media reply handler
async function handleMediaReply(ctx, mediaType) {
    try {
        const userId = ctx.from.id;
        
        // Check if we're awaiting a reply response
        if (!awaitingReplyResponse || !tempReplyWord) {
            return false; // Not handling this media as a reply
        }

        console.log(`Processing ${mediaType} as a reply for trigger word: ${tempReplyWord}`);
        
        let fileId, additionalData = {};
        
        // Extract the appropriate file ID based on media type
        switch (mediaType) {
            case 'photo':
                if (ctx.message.photo && ctx.message.photo.length > 0) {
                    fileId = ctx.message.photo[ctx.message.photo.length - 1].file_id;
                } else {
                    console.error('Invalid photo message structure:', ctx.message);
                    return false;
                }
                break;
            case 'wcac':
                if (ctx.message.zxcxz) {
                    fileId = ctx.message.zxczxc.file_id;
                } else {
                    console.error('Invalid video message structure:', ctx.message);
                    return false;
                }
                break;
            case 'animation':
                if (ctx.message.animation) {
                    fileId = ctx.message.animation.file_id;
                } else {
                    console.error('Invalid animation message structure:', ctx.message);
                    return false;
                }
                break;
            case 'document':
                if (ctx.message.document) {
                    fileId = ctx.message.document.file_id;
                } else {
                    console.error('Invalid document message structure:', ctx.message);
                    return false;
                }
                break;
            case 'sticker':
                if (ctx.message.sticker) {
                    fileId = ctx.message.sticker.file_id;
                } else {
                    console.error('Invalid sticker message structure:', ctx.message);
                    return false;
                }
                break;
            default:
                console.error('Unsupported media type:', mediaType);
                return false;
        }
        
        try {
            // Save to database
            const db = await ensureDatabaseInitialized();
            await db.collection('replies').insertOne({
                trigger_word: tempReplyWord.trim().toLowerCase(),
                type: mediaType,
                file_id: fileId,
                created_at: new Date(),
                created_by: userId,
                username: ctx.from.username || ''
            });
            
            // Send confirmation
            await ctx.reply(`‚úÖ ÿ™ŸÖ ÿ•ÿ∂ÿßŸÅÿ© ${getMediaTypeInArabic(mediaType)} ŸÉÿ±ÿØ ŸÑŸÑŸÉŸÑŸÖÿ© "${tempReplyWord}" ÿ®ŸÜÿ¨ÿßÿ≠.`);
            
            // Reset state
            awaitingReplyResponse = false;
            tempReplyWord = '';
            
            return true; // Successfully handled
        } catch (error) {
            console.error(`Error saving ${mediaType} reply:`, error);
            await ctx.reply(`‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ≠ŸÅÿ∏ ${getMediaTypeInArabic(mediaType)} ŸÉÿ±ÿØ. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.`);
            
            // Reset state even on error
            awaitingReplyResponse = false;
            tempReplyWord = '';
            
            return true; // We still handled it, even though there was an error
        }
    } catch (error) {
        console.error(`Error in handleMediaReply for ${mediaType}:`, error);
        return false; // Error occurred
    }
}

// Helper function to get Arabic names for media types
function getMediaTypeInArabic(mediaType) {
    const mediaTypes = {
        'photo': 'ÿßŸÑÿµŸàÿ±ÿ©',
       
        'animation': 'ÿßŸÑÿµŸàÿ±ÿ© ÿßŸÑŸÖÿ™ÿ≠ÿ±ŸÉÿ©',
        'document': 'ÿßŸÑŸÖÿ≥ÿ™ŸÜÿØ',
        'sticker': 'ÿßŸÑŸÖŸÑÿµŸÇ'
    };
    
    return mediaTypes[mediaType] || mediaType;
}

// Clean up the duplicate handlers and use this single handler for each media type
// Update your photo handler
// Update your photo handler




// Animation/GIF handler
// Update the animation handler to also handle replies
bot.on('animation', async (ctx) => {
    try {
        const chatId = ctx.chat.id;
        const isRestricted = gifRestrictionStatus.get(chatId);

        if (isRestricted) {
            const chatMember = await ctx.telegram.getChatMember(chatId, ctx.from.id);
            
            if (chatMember.status !== 'administrator' && chatMember.status !== 'creator') {
                await ctx.deleteMessage();
                await ctx.reply('‚ùå ÿπÿ∞ÿ±Ÿãÿßÿå ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿµŸàÿ± ÿßŸÑŸÖÿ™ÿ≠ÿ±ŸÉÿ© ÿ∫Ÿäÿ± ŸÖÿ≥ŸÖŸàÿ≠ ÿ≠ÿßŸÑŸäŸãÿß ŸÑŸÑÿ£ÿπÿ∂ÿßÿ° ÿßŸÑÿπÿßÿØŸäŸäŸÜ ŸÅŸä Ÿáÿ∞Ÿá ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ©.');
                return;
            }
        }

        // Handle animation reply if awaiting response
        if (awaitingReplyResponse && tempReplyWord) {
            const userId = ctx.from.id;
            const username = ctx.from.username || '';
            let fileId = ctx.message.animation.file_id;
            let replyText;

            if (ctx.chat.username) {
                replyText = `https://t.me/${ctx.chat.username}/${ctx.message.message_id}`;
            } else {
                replyText = fileId;
            }

            try {
                // Save to database
                const db = await ensureDatabaseInitialized();
                await db.collection('replies').insertOne({
                    user_id: userId,
                    username: username,
                    trigger_word: tempReplyWord.trim(),
                    reply_text: replyText,
                    media_type: 'animation',
                    file_id: fileId,
                    created_at: new Date()
                });
                
                await ctx.reply(`‚úÖ ÿ™ŸÖ ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ±ÿØ ÿ®ŸÜÿ¨ÿßÿ≠!\nÿßŸÑŸÉŸÑŸÖÿ©: ${tempReplyWord}\nŸÜŸàÿπ ÿßŸÑÿ±ÿØ: ÿµŸàÿ±ÿ© ŸÖÿ™ÿ≠ÿ±ŸÉÿ©`);
                
                // Reset the awaiting state
                awaitingReplyResponse = false;
                tempReplyWord = '';
                
                return;
            } catch (error) {
                console.error('‚ùå ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ≠ŸÅÿ∏ ÿßŸÑÿ±ÿØ:', error);
                await ctx.reply('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ≠ŸÅÿ∏ ÿßŸÑÿ±ÿØ.');
                
                // Reset the awaiting state
                awaitingReplyResponse = false;
                tempReplyWord = '';
                
                return;
            }
        }

        // Continue with any existing GIF handling logic...
    } catch (error) {
        console.error('Error handling GIF message:', error);
    }
});

// Document handler
bot.on('document', async (ctx) => {
    try {
        // Check if this is a reply to a trigger word
        if (await handleMediaReply(ctx, 'document')) {
            return; // Media was handled as a reply
        }
        
        // Additional document handling logic can go here
    } catch (error) {
        console.error('Error handling document message:', error);
    }
});

// Sticker handler
bot.on('sticker', async (ctx) => {
    const userId = ctx.from.id;
    
    // Check if we're awaiting a reply response
    if (awaitingReplyResponse && tempReplyWord) {
        try {
            const fileId = ctx.message.sticker.file_id;
            const botId = ctx.botInfo.id;
            
            // Get database connection
            const db = await ensureDatabaseInitialized();
            
            // Save the sticker reply to database
            await db.collection('replies').updateOne(
                { bot_id: botId, trigger_word: tempReplyWord },
                { 
                    $set: { 
                        bot_id: botId,
                        trigger_word: tempReplyWord, 
                        type: 'sticker',
                        content: fileId,
                        file_id: fileId,  // For backward compatibility
                        created_at: new Date(),
                        updated_at: new Date(),
                        created_by: userId,
                        username: ctx.from.username || ''
                    }
                },
                { upsert: true }
            );
            
            // Confirm to the user
            await ctx.reply(`‚úÖ ÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿßŸÑŸÖŸÑÿµŸÇ ŸÉÿ±ÿØ ŸÑŸÑŸÉŸÑŸÖÿ© "${tempReplyWord}"`);
            
            // Reset the state
            awaitingReplyResponse = false;
            tempReplyWord = '';
        } catch (error) {
            console.error('Error saving sticker reply:', error);
            await ctx.reply('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ≠ŸÅÿ∏ ÿßŸÑŸÖŸÑÿµŸÇ. ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.');
            awaitingReplyResponse = false;
            tempReplyWord = '';
        }
    }
});


// Implement the other helper functions (handleQuizAnswer, checkForAutomaticReply, sendReply, etc.) 
// based on your existing code and requirements.

async function checkForAutomaticReply(ctx) {
    const text = ctx.message.text.trim().toLowerCase();
    const botId = ctx.botInfo.id;

    try {
        const db = await ensureDatabaseInitialized();
        
        // First, try to find a bot-specific reply
        let reply = await db.collection('replies').findOne({
            bot_id: botId,
            trigger_word: text
        });

        // If no bot-specific reply is found, try to find a global reply
        if (!reply) {
            reply = await db.collection('replies').findOne({
                trigger_word: text,
                bot_id: { $exists: false }
            });
        }

        return reply;
    } catch (error) {
        console.error('Error checking for automatic reply:', error);
        return null;
    }
}


    
    function showDevelopersMenu(ctx) {
        const message = ' Ÿäÿ±ÿ¨Ÿâ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿßŸàÿßŸÖÿ± ŸÑÿ±ŸÅÿπ ŸÖÿ∑Ÿàÿ± ÿßÿ≥ÿßÿ≥Ÿä ÿßŸà ŸÖÿ∑Ÿàÿ± ÿ´ÿßŸÜŸä , ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ - ÿßÿÆÿ™ÿ± ÿßŸÑÿ•ÿ¨ÿ±ÿßÿ° ÿßŸÑŸÖÿ∑ŸÑŸàÿ®:';
        const keyboard = {
            inline_keyboard: [
                [
                    { text: '‚Ä¢ ÿßŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ ‚Ä¢', callback_data: 'list_developers' },
                    { text: '‚Ä¢ ÿ≠ÿ∞ŸÅ ÿßŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ ‚Ä¢', callback_data: 'delete_developers' }
                ],
                [
                    { text: '‚Ä¢ ÿßŸÑÿ´ÿßŸÜŸàŸäŸäŸÜ ‚Ä¢', callback_data: 'list_secondary_developers' },
                    { text: '‚Ä¢ ÿ≠ÿ∞ŸÅ ÿßŸÑÿ´ÿßŸÜŸàŸäŸäŸÜ ‚Ä¢', callback_data: 'delete_secondary_developers' }
                ],
                
                [{ text: 'üîô ÿ±ÿ¨Ÿàÿπ', callback_data: 'back_to_dev_panel' }]
            ]
        };
    
        ctx.editMessageText(message, { reply_markup: keyboard });
    }
    
    // Add a new function to show the bot name menu
    function showBotNameMenu(ctx) {
        const message = 'ŸÇÿ≥ŸÖ ÿßÿ≥ŸÖ ÿßŸÑÿ®Ÿàÿ™ - ÿßÿÆÿ™ÿ± ÿßŸÑÿ•ÿ¨ÿ±ÿßÿ° ÿßŸÑŸÖÿ∑ŸÑŸàÿ®:';
        const keyboard = {
            inline_keyboard: [
                [{ text: '‚Ä¢ ÿ™ÿ∫ŸäŸäÿ± ÿßÿ≥ŸÖ ÿßŸÑÿ®Ÿàÿ™ ‚Ä¢', callback_data: 'change_bot_name' }],
                [{ text: '‚Ä¢ ÿπÿ±ÿ∂ ÿßÿ≥ŸÖ ÿßŸÑÿ®Ÿàÿ™ ÿßŸÑÿ≠ÿßŸÑŸä ‚Ä¢', callback_data: 'show_current_bot_name' }],
                [{ text: 'üîô ÿ±ÿ¨Ÿàÿπ', callback_data: 'back_to_dev_panel' }]
            ]
        };
    
        ctx.editMessageText(message, { reply_markup: keyboard });
    }

    bot.action('list_developers', async (ctx) => {
        if (await isDeveloper(ctx, ctx.from.id)) {
            await ctx.answerCbQuery('ÿπÿ±ÿ∂ ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ');
            try {
                const db = await ensureDatabaseInitialized();
                const botId = ctx.botInfo.id; // Get the current bot's ID
                const developers = await db.collection('developers').find({ bot_id: botId }).toArray(); // Filter by bot_id
                
                if (developers.length > 0) {
                    const developersList = await Promise.all(developers.map(async (dev, index) => {
                        let displayName = dev.username ? `@${dev.username}` : 'ÿ®ÿØŸàŸÜ ŸÖÿπÿ±ŸÅ';
                        try {
                            const user = await ctx.telegram.getChat(dev.user_id);
                            displayName = user.username ? `@${user.username}` : user.first_name || 'ÿ®ÿØŸàŸÜ ÿßÿ≥ŸÖ';
                        } catch (error) {
                            console.error(`Error fetching user info for ${dev.user_id}:`, error);
                        }
                        return `${index + 1}. ${displayName} ‚Ü´ ŸÖÿπÿ±ŸÅ ‚Üì\n${dev.user_id}`;
                    }));
                    await ctx.reply(`ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ:\n\n${developersList.join('\n\n')}`);
                } else {
                    await ctx.reply('ŸÑÿß ŸäŸàÿ¨ÿØ ŸÖÿ∑Ÿàÿ±ŸäŸÜ ÿ≠ÿßŸÑŸäŸãÿß.');
                }
            } catch (error) {
                console.error('Error fetching developers:', error);
                await ctx.reply('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ¨ŸÑÿ® ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ. ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ŸÑÿßÿ≠ŸÇŸãÿß.');
            }
        } else {
            ctx.answerCbQuery('ÿπÿ∞ÿ±Ÿãÿßÿå Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ± ŸÑŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ ŸÅŸÇÿ∑', { show_alert: true });
        }
    });
    bot.action('bot_subscription', async (ctx) => {
        await ctx.answerCbQuery();
        await ctx.editMessageText(
            'üìÖ ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßÿ¥ÿ™ÿ±ÿßŸÉ ÿßŸÑÿ®Ÿàÿ™:\n\n' +
            'üîπ ÿ≠ÿßŸÑÿ© ÿßŸÑÿ®Ÿàÿ™: ŸÖÿ¨ÿßŸÜŸä\n' +
            'üî∏ Ÿáÿ∞Ÿá ÿßŸÑŸÜÿ≥ÿÆÿ© ŸÑŸäÿ≥ ŸÑŸáÿß ÿßÿ¥ÿ™ÿ±ÿßŸÉ\n\n' +
            'ŸÑŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿßŸÑŸÜÿ≥ÿÆÿ© ÿßŸÑŸÉÿßŸÖŸÑÿ© ÿßŸÑŸÖÿØŸÅŸàÿπÿ©ÿå Ÿäÿ±ÿ¨Ÿâ ŸÖÿ±ÿßÿ¨ÿπÿ© ŸÇŸÜÿßÿ© ÿßŸÑÿ≥Ÿàÿ±ÿ≥.\n' +
            'ŸÇŸÜÿßÿ© ÿ≥Ÿàÿ±ÿ≥ ÿ™Ÿàÿ®ÿßŸÉ\n' +
            'üîπ https://t.me/T0_B7',
            {
                reply_markup: {
                    inline_keyboard: [
                        [{ text: 'üîó ŸÇŸÜÿßÿ© ÿßŸÑÿ≥Ÿàÿ±ÿ≥', url: 'https://t.me/T0_B7' }],
                        [{ text: 'üîô ÿ±ÿ¨Ÿàÿπ', callback_data: 'back_to_source_menu' }]
                    ]
                },
                disable_web_page_preview: true
            }
        );
    });
    
    bot.action('source_update', async (ctx) => {
        await ctx.answerCbQuery();
        await ctx.editMessageText(
            'üîÑ ÿ¨ÿßÿ±Ÿä ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ®Ÿàÿ™...\n\nŸäÿ±ÿ¨Ÿâ ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ±ÿå ÿ≥Ÿäÿ™ŸÖ ÿ•ÿπŸÑÿßŸÖŸÉ ÿπŸÜÿØ ÿßŸÉÿ™ŸÖÿßŸÑ ÿßŸÑÿ™ÿ≠ÿØŸäÿ´.',
            {
                reply_markup: {
                    inline_keyboard: [[{ text: 'üîô ÿ±ÿ¨Ÿàÿπ', callback_data: 'back_to_source_menu' }]]
                }
            }
        );
    });
    
    bot.action('main_bot_dev', async (ctx) => {
        try {
            const db = await ensureDatabaseInitialized();
            const mainDev = await db.collection('developers').findOne({});
            
            if (mainDev) {
                await ctx.answerCbQuery();
                await ctx.editMessageText(
                    'üë®‚Äçüíª ŸÖÿπŸÑŸàŸÖÿßÿ™ ŸÖÿ∑Ÿàÿ± ÿßŸÑÿ®Ÿàÿ™ ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿä:\n\n' +
                    `üîπ ÿßŸÑÿßÿ≥ŸÖ: ${mainDev.username || 'ÿ∫Ÿäÿ± ŸÖÿ≠ÿØÿØ'}\n` +
                    `üî∏ ŸÖÿπÿ±ŸÅ ÿ™ŸäŸÑŸäÿ¨ÿ±ÿßŸÖ: @${mainDev.username || 'ÿ∫Ÿäÿ± ŸÖÿ≠ÿØÿØ'}\n` +
                    `üîπ ÿßŸÑÿ±ŸÇŸÖ ÿßŸÑÿ™ÿπÿ±ŸäŸÅŸä: ${mainDev.user_id}\n\n` +
                    'üåü ÿ¥ŸÉÿ±ÿßŸã ŸÑÿ¨ŸáŸàÿØŸá ŸÅŸä ÿ™ÿ∑ŸàŸäÿ± Ÿàÿ•ÿØÿßÿ±ÿ© ÿßŸÑÿ®Ÿàÿ™!',
                    {
                        reply_markup: {
                            inline_keyboard: [[{ text: 'üîô ÿ±ÿ¨Ÿàÿπ', callback_data: 'back_to_source_menu' }]]
                        }
                    }
                );
            } else {
                await ctx.answerCbQuery('ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑŸÖÿ∑Ÿàÿ± ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿä', { show_alert: true });
            }
        } catch (error) {
            console.error('Error fetching main developer info:', error);
            await ctx.answerCbQuery('ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ¨ŸÑÿ® ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑŸÖÿ∑Ÿàÿ± ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿä', { show_alert: true });
        }
    });
    
    bot.action('source_programmer', async (ctx) => {
        await ctx.answerCbQuery();
        await ctx.editMessageMedia(
            {
                type: 'photo',
                media: 'https://postimg.cc/WtX4j0ZG',
                caption: 'üåü ŸÖÿ®ÿ±ŸÖÿ¨ ÿßŸÑÿ≥Ÿàÿ±ÿ≥\n\n' +
                         'üë®‚Äçüíª ÿßŸÑŸÖÿ∑Ÿàÿ±: @Lorisiv\n\n' +
                         'üöÄ ŸÖÿ®ÿ±ŸÖÿ¨ ŸÖÿ™ŸÖŸäÿ≤ ŸàŸÖÿ®ÿØÿπ ŸÅŸä ÿπÿßŸÑŸÖ ÿßŸÑÿ®ÿ±ŸÖÿ¨ÿ© Ÿàÿ™ÿ∑ŸàŸäÿ± ÿßŸÑÿ®Ÿàÿ™ÿßÿ™\n' +
                         'üí° ÿµÿßÿ≠ÿ® ÿ£ŸÅŸÉÿßÿ± ŸÖÿ®ÿ™ŸÉÿ±ÿ© Ÿàÿ≠ŸÑŸàŸÑ ÿ™ŸÇŸÜŸäÿ© ŸÖÿ™ŸÇÿØŸÖÿ©\n' +
                         'üîß ÿÆÿ®ÿ±ÿ© Ÿàÿßÿ≥ÿπÿ© ŸÅŸä ÿ™ÿ∑ŸàŸäÿ± Ÿàÿ™ÿ≠ÿ≥ŸäŸÜ ÿ£ÿØÿßÿ° ÿßŸÑÿ®Ÿàÿ™ÿßÿ™\n\n' +
                         'üì© ŸÑŸÑÿ™ŸàÿßÿµŸÑ ŸàÿßŸÑÿßÿ≥ÿ™ŸÅÿ≥ÿßÿ±ÿßÿ™: @Lorisiv'
            },
            {
                reply_markup: {
                    inline_keyboard: [[{ text: 'üîô ÿ±ÿ¨Ÿàÿπ', callback_data: 'back_to_source_menu' }]]
                }
            }
        );
    })
    
    bot.action('source_channel', async (ctx) => {
        await ctx.answerCbQuery();
        await ctx.editMessageText(
            'üì¢ ŸÇŸÜÿßÿ© ÿßŸÑÿ≥Ÿàÿ±ÿ≥ ÿßŸÑÿ±ÿ≥ŸÖŸäÿ©\n\n' +
            'üîó ÿßŸÑÿ±ÿßÿ®ÿ∑: https://t.me/ctrlsrc\n\n' +
            'üåü ÿßŸÜÿ∂ŸÖ ÿßŸÑÿ¢ŸÜ ŸÑŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ:\n' +
            '‚Ä¢ ÿ¢ÿÆÿ± ÿßŸÑÿ™ÿ≠ÿØŸäÿ´ÿßÿ™ ŸàÿßŸÑÿ•ÿµÿØÿßÿ±ÿßÿ™ ÿßŸÑÿ¨ÿØŸäÿØÿ©\n' +
            '‚Ä¢ ŸÜÿµÿßÿ¶ÿ≠ Ÿàÿ≠ŸäŸÑ ŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿ®Ÿàÿ™ ÿ®ÿ¥ŸÉŸÑ ÿ£ŸÅÿ∂ŸÑ\n' +
            '‚Ä¢ ÿßŸÑÿØÿπŸÖ ÿßŸÑŸÅŸÜŸä ŸàÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© ÿπŸÑŸâ ÿßÿ≥ÿ™ŸÅÿ≥ÿßÿ±ÿßÿ™ŸÉŸÖ\n' +
            '‚Ä¢ ŸÖÿ¥ÿßÿ±ŸÉÿ© ÿßŸÑÿ£ŸÅŸÉÿßÿ± ŸàÿßŸÑÿßŸÇÿ™ÿ±ÿßÿ≠ÿßÿ™ ŸÑÿ™ÿ∑ŸàŸäÿ± ÿßŸÑÿ≥Ÿàÿ±ÿ≥\n\n' +
            'üöÄ ŸÉŸÜ ÿ¨ÿ≤ÿ°Ÿãÿß ŸÖŸÜ ŸÖÿ¨ÿ™ŸÖÿπŸÜÿß ÿßŸÑŸÖÿ™ŸÜÿßŸÖŸä!',
            {
                reply_markup: {
                    inline_keyboard: [[{ text: 'üîô ÿ±ÿ¨Ÿàÿπ', callback_data: 'back_to_source_menu' }]]
                }
            }
        );
    });
    
    bot.action('back_to_source_menu', async (ctx) => {
        await ctx.answerCbQuery();
        try {
            await ctx.editMessageText('ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ≥Ÿàÿ±ÿ≥ - ÿßÿÆÿ™ÿ± ÿßŸÑÿ•ÿ¨ÿ±ÿßÿ° ÿßŸÑŸÖÿ∑ŸÑŸàÿ®:', {
                reply_markup: {
                    inline_keyboard: [
                        [{ text: '‚Ä¢ ÿ™ÿßÿ±ŸäÿÆ ÿßÿ¥ÿ™ÿ±ÿßŸÉ ÿßŸÑÿ®Ÿàÿ™ ‚Ä¢', callback_data: 'bot_subscription' }],
                        [{ text: '‚Ä¢ ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ≥Ÿàÿ±ÿ≥ ‚Ä¢', callback_data: 'source_update' }],
                        [{ text: '‚Ä¢ ŸÖÿ∑Ÿàÿ± ÿßŸÑÿ®Ÿàÿ™ ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿä ‚Ä¢', callback_data: 'main_bot_dev' }],
                        [{ text: '‚Ä¢ ŸÖÿ®ÿ±ŸÖÿ¨ ÿßŸÑÿ≥Ÿàÿ±ÿ≥ ‚Ä¢', callback_data: 'source_programmer' }],
                        [{ text: '‚Ä¢ ŸÇŸÜÿßÿ© ÿßŸÑÿ≥Ÿàÿ±ÿ≥ ‚Ä¢', callback_data: 'source_channel' }],
                        [{ text: 'üîô ÿ±ÿ¨Ÿàÿπ', callback_data: 'back_to_dev_panel' }]
                    ]
                }
            });
        } catch (error) {
            if (error.description === 'Bad Request: message is not modified: specified new message content and reply markup are exactly the same as a current content and reply markup of the message') {
                // If the message content is the same, we can ignore this error
                console.log('Message content is the same, no need to update');
            } else if (error.description === 'Bad Request: there is no text in the message to edit') {
                // If there's no text to edit (e.g., coming from an image message), send a new message
                await ctx.deleteMessage();
                await ctx.reply('ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ≥Ÿàÿ±ÿ≥ - ÿßÿÆÿ™ÿ± ÿßŸÑÿ•ÿ¨ÿ±ÿßÿ° ÿßŸÑŸÖÿ∑ŸÑŸàÿ®:', {
                    reply_markup: {
                        inline_keyboard: [
                            [{ text: '‚Ä¢ ÿ™ÿßÿ±ŸäÿÆ ÿßÿ¥ÿ™ÿ±ÿßŸÉ ÿßŸÑÿ®Ÿàÿ™ ‚Ä¢', callback_data: 'bot_subscription' }],
                            [{ text: '‚Ä¢ ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ≥Ÿàÿ±ÿ≥ ‚Ä¢', callback_data: 'source_update' }],
                            [{ text: '‚Ä¢ ŸÖÿ∑Ÿàÿ± ÿßŸÑÿ®Ÿàÿ™ ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿä ‚Ä¢', callback_data: 'main_bot_dev' }],
                            [{ text: '‚Ä¢ ŸÖÿ®ÿ±ŸÖÿ¨ ÿßŸÑÿ≥Ÿàÿ±ÿ≥ ‚Ä¢', callback_data: 'source_programmer' }],
                            [{ text: '‚Ä¢ ŸÇŸÜÿßÿ© ÿßŸÑÿ≥Ÿàÿ±ÿ≥ ‚Ä¢', callback_data: 'source_channel' }],
                            [{ text: 'üîô ÿ±ÿ¨Ÿàÿπ', callback_data: 'back_to_dev_panel' }]
                        ]
                    }
                });
            } else {
                // For other errors, log them and inform the user
                console.error('Error in back_to_source_menu:', error);
                await ctx.reply('ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿßŸÑÿπŸàÿØÿ© ÿ•ŸÑŸâ ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ≥Ÿàÿ±ÿ≥. ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.');
            }
        }
    });
    bot.action('delete_developers', async (ctx) => {
        if (await isDeveloper(ctx, ctx.from.id)) {
            await ctx.answerCbQuery('ÿ≠ÿ∞ŸÅ ÿßŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ');
            try {
                const db = await ensureDatabaseInitialized();
                const botId = ctx.botInfo.id; // Get the current bot's ID
                const developers = await db.collection('developers').find({ bot_id: botId }).toArray(); // Filter by bot_id
                
                if (developers.length > 0) {
                    const keyboard = await Promise.all(developers.map(async (dev, index) => {
                        let displayName = dev.username ? `@${dev.username}` : 'ÿ®ÿØŸàŸÜ ŸÖÿπÿ±ŸÅ';
                        try {
                            const user = await ctx.telegram.getChat(dev.user_id);
                            displayName = user.username ? `@${user.username}` : user.first_name || 'ÿ®ÿØŸàŸÜ ÿßÿ≥ŸÖ';
                        } catch (error) {
                            console.error(`Error fetching user info for ${dev.user_id}:`, error);
                        }
                        return [{
                            text: `${index + 1}. ${displayName}`,
                            callback_data: `confirm_delete_dev_${dev.user_id}`
                        }];
                    }));
    
                    keyboard.push([{ text: 'ÿ•ŸÑÿ∫ÿßÿ°', callback_data: 'cancel_delete_developers' }]);
    
                    await ctx.editMessageText('ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ:', {
                        reply_markup: { inline_keyboard: keyboard }
                    });
                } else {
                    await ctx.editMessageText('ŸÑÿß ŸäŸàÿ¨ÿØ ŸÖÿ∑Ÿàÿ±ŸäŸÜ ŸÑÿ≠ÿ∞ŸÅŸáŸÖ.');
                }
            } catch (error) {
                console.error('Error fetching developers for deletion:', error);
                await ctx.editMessageText('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ¨ŸÑÿ® ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ. ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ŸÑÿßÿ≠ŸÇŸãÿß.');
            }
        } else {
            ctx.answerCbQuery('ÿπÿ∞ÿ±Ÿãÿßÿå Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ± ŸÑŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ ŸÅŸÇÿ∑', { show_alert: true });
        }
    });
    
    bot.action(/^confirm_delete_dev_(\d+)$/, async (ctx) => {
        const devIdToDelete = ctx.match[1];
        if (await isDeveloper(ctx, ctx.from.id)) {
            try {
                const db = await ensureDatabaseInitialized();
                const developer = await db.collection('developers').findOne({ user_id: parseInt(devIdToDelete) });
                
                if (developer) {
                    const devUsername = developer.username ? `@${developer.username}` : `User ID: ${devIdToDelete}`;
                    await ctx.editMessageText(`ŸáŸÑ ÿ£ŸÜÿ™ ŸÖÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ≠ÿ∞ŸÅ ÿßŸÑŸÖÿ∑Ÿàÿ±: ${devUsername}ÿü`, {
                        reply_markup: {
                            inline_keyboard: [
                                [{ text: '‚Ä¢ ÿ≠ÿ∞ŸÅ ‚Ä¢', callback_data: `delete_dev_${devIdToDelete}` }],
                                [{ text: 'ÿ•ŸÑÿ∫ÿßÿ°', callback_data: 'cancel_delete_developers' }]
                            ]
                        }
                    });
                } else {
                    await ctx.answerCbQuery('ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖÿ∑Ÿàÿ±', { show_alert: true });
                }
            } catch (error) {
                console.error('Error confirming developer deletion:', error);
                await ctx.answerCbQuery('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ™ÿ£ŸÉŸäÿØ ÿ≠ÿ∞ŸÅ ÿßŸÑŸÖÿ∑Ÿàÿ±', { show_alert: true });
            }
        } else {
            ctx.answerCbQuery('ÿπÿ∞ÿ±Ÿãÿßÿå Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ± ŸÑŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ ŸÅŸÇÿ∑', { show_alert: true });
        }
    });
    
    bot.action(/^delete_dev_(\d+)$/, async (ctx) => {
        const devIdToDelete = ctx.match[1];
        if (await isDeveloper(ctx, ctx.from.id)) {
            try {
                const db = await ensureDatabaseInitialized();
                const result = await db.collection('developers').deleteOne({ user_id: parseInt(devIdToDelete) });
                
                if (result.deletedCount > 0) {
                    await ctx.answerCbQuery('ÿ™ŸÖ ÿ≠ÿ∞ŸÅ ÿßŸÑŸÖÿ∑Ÿàÿ± ÿ®ŸÜÿ¨ÿßÿ≠');
                    await ctx.editMessageText('ÿ™ŸÖ ÿ≠ÿ∞ŸÅ ÿßŸÑŸÖÿ∑Ÿàÿ± ÿ®ŸÜÿ¨ÿßÿ≠. ÿ™ŸÖ ÿ•ÿ≤ÿßŸÑÿ© ÿ¨ŸÖŸäÿπ ÿµŸÑÿßÿ≠Ÿäÿßÿ™Ÿá Ÿàÿ±ÿ™ÿ®ÿ™Ÿá.', {
                        reply_markup: {
                            inline_keyboard: [
                                [{ text: 'üîô ÿ±ÿ¨Ÿàÿπ', callback_data: 'back_to_dev_panel' }]
                            ]
                        }
                    });
                } else {
                    await ctx.answerCbQuery('ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖÿ∑Ÿàÿ±', { show_alert: true });
                    await ctx.editMessageText('ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖÿ∑Ÿàÿ± ÿßŸÑŸÖÿ≠ÿØÿØ.', {
                        reply_markup: {
                            inline_keyboard: [
                                [{ text: 'üîô ÿ±ÿ¨Ÿàÿπ', callback_data: 'back_to_dev_panel' }]
                            ]
                        }
                    });
                }
            } catch (error) {
                console.error('Error deleting developer:', error);
                await ctx.answerCbQuery('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ≠ÿ∞ŸÅ ÿßŸÑŸÖÿ∑Ÿàÿ±', { show_alert: true });
                await ctx.editMessageText('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ≠ÿ∞ŸÅ ÿßŸÑŸÖÿ∑Ÿàÿ±. ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ŸÑÿßÿ≠ŸÇŸãÿß.', {
                    reply_markup: {
                        inline_keyboard: [
                            [{ text: 'üîô ÿ±ÿ¨Ÿàÿπ', callback_data: 'back_to_dev_panel' }]
                        ]
                    }
                });
            }
        } else {
            ctx.answerCbQuery('ÿπÿ∞ÿ±Ÿãÿßÿå Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ± ŸÑŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ ŸÅŸÇÿ∑', { show_alert: true });
        }
    });
    
    // Handle cancellation of developer deletion
    bot.action('cancel_delete_developers', async (ctx) => {
        if (await isDeveloper(ctx, ctx.from.id)) {
            await ctx.answerCbQuery('ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿπŸÖŸÑŸäÿ© ÿßŸÑÿ≠ÿ∞ŸÅ');
            showDevelopersMenu(ctx);
        } else {
            ctx.answerCbQuery('ÿπÿ∞ÿ±Ÿãÿßÿå Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ± ŸÑŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ ŸÅŸÇÿ∑', { show_alert: true });
        }
    });


    bot.action('overall_stats', async (ctx) => {
        await ctx.answerCbQuery();
        const stats = await getOverallStats();
        await ctx.editMessageText(
            `üìä ÿßŸÑÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑÿπÿßŸÖÿ©:\n\n` +
            `üë• ÿπÿØÿØ ÿßŸÑŸÖÿ¥ÿ™ÿ±ŸÉŸäŸÜ: ${stats.subscribers}\n` +
            `üë• ÿπÿØÿØ ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™: ${stats.groups}\n` +
            `üìà ÿ•ÿ¨ŸÖÿßŸÑŸä ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ: ${stats.total}`,
            { reply_markup: { inline_keyboard: [[{ text: 'üîô ÿ±ÿ¨Ÿàÿπ', callback_data: 'back_to_statistics' }]] } }
        );
    });
    
    bot.action('subscribers_stats', async (ctx) => {
        await ctx.answerCbQuery();
        const subscribersCount = await getSubscribersCount();
        await ctx.editMessageText(
            `üë• ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑŸÖÿ¥ÿ™ÿ±ŸÉŸäŸÜ:\n\n` +
            `ÿπÿØÿØ ÿßŸÑŸÖÿ¥ÿ™ÿ±ŸÉŸäŸÜ ÿßŸÑŸÜÿ¥ÿ∑ŸäŸÜ: ${subscribersCount}`,
            { reply_markup: { inline_keyboard: [[{ text: 'üîô ÿ±ÿ¨Ÿàÿπ', callback_data: 'back_to_statistics' }]] } }
        );
    });
    
    bot.action('groups_stats', async (ctx) => {
        await ctx.answerCbQuery();
        const groupsCount = await getGroupsCount();
        await ctx.editMessageText(
            `üë• ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™:\n\n` +
            `ÿπÿØÿØ ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™ ÿßŸÑŸÜÿ¥ÿ∑ÿ©: ${groupsCount}`,
            { reply_markup: { inline_keyboard: [[{ text: 'üîô ÿ±ÿ¨Ÿàÿπ', callback_data: 'back_to_statistics' }]] } }
        );
    });
    
    bot.action('backup_data', async (ctx) => {
        await ctx.answerCbQuery();
        const backupData = await generateBackup();
        await ctx.replyWithDocument(
            { source: Buffer.from(JSON.stringify(backupData)), filename: 'backup.json' },
            { caption: 'Ÿáÿ∞Ÿá ŸÜÿ≥ÿÆÿ© ÿßÿ≠ÿ™Ÿäÿßÿ∑Ÿäÿ© ŸÖŸÜ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ®Ÿàÿ™.' }
        );
    });
    
    bot.action('clean_subscribers', async (ctx) => {
        await ctx.answerCbQuery();
        const cleanedCount = await cleanSubscribers();
        await ctx.editMessageText(
            `üßπ ÿ™ŸÖ ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑŸÖÿ¥ÿ™ÿ±ŸÉŸäŸÜ:\n\n` +
            `ÿ™ŸÖ ÿ•ÿ≤ÿßŸÑÿ© ${cleanedCount} ŸÖÿ¥ÿ™ÿ±ŸÉ ÿ∫Ÿäÿ± ŸÜÿ¥ÿ∑.`,
            { reply_markup: { inline_keyboard: [[{ text: 'üîô ÿ±ÿ¨Ÿàÿπ', callback_data: 'back_to_statistics' }]] } }
        );
    });
    
    bot.action('clean_groups', async (ctx) => {
        await ctx.answerCbQuery();
        const cleanedCount = await cleanGroups();
        await ctx.editMessageText(
            `üßπ ÿ™ŸÖ ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™:\n\n` +
            `ÿ™ŸÖ ÿ•ÿ≤ÿßŸÑÿ© ${cleanedCount} ŸÖÿ¨ŸÖŸàÿπÿ© ÿ∫Ÿäÿ± ŸÜÿ¥ÿ∑ÿ©.`,
            { reply_markup: { inline_keyboard: [[{ text: 'üîô ÿ±ÿ¨Ÿàÿπ', callback_data: 'back_to_statistics' }]] } }
        );
    });
    
    bot.action('back_to_statistics', async (ctx) => {
        await ctx.answerCbQuery();
        await showStatisticsMenu(ctx);
    });

    // Add handlers for the new bot name actions
    bot.action('dev_bot_name', async (ctx) => {
        if (await isDeveloper(ctx, ctx.from.id)) {
            await ctx.answerCbQuery();
            showBotNameMenu(ctx);
        }
    });
    
   // Add new action handlers for custom chat names
bot.action('set_custom_chat_name', async (ctx) => {
    if (await isDeveloper(ctx, ctx.from.id)) {
        await ctx.answerCbQuery();
        ctx.reply('ÿßŸÑÿ±ÿ¨ÿßÿ° ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿßÿ≥ŸÖ ÿßŸÑÿÆÿßÿµ ŸÑŸÑÿ®Ÿàÿ™ ŸÅŸä Ÿáÿ∞Ÿá ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©:');
        // Set a flag to indicate we're waiting for the custom name
        ctx.session.awaitingCustomChatName = true;
    }
});

bot.action('remove_custom_chat_name', async (ctx) => {
    if (await isDeveloper(ctx, ctx.from.id)) {
        await ctx.answerCbQuery();
        const chatId = ctx.chat.id;
        try {
            const connection = await pool.getConnection();
            await connection.query('DELETE FROM bot_custom_names WHERE chat_id = ?', [chatId]);
            connection.release();
            ctx.reply('‚úÖ ÿ™ŸÖ ÿ•ÿ≤ÿßŸÑÿ© ÿßÿ≥ŸÖ ÿßŸÑÿ®Ÿàÿ™ ÿßŸÑÿÆÿßÿµ ŸÑŸáÿ∞Ÿá ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©.');
        } catch (error) {
            console.error('Error removing custom bot name:', error);
            ctx.reply('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ•ÿ≤ÿßŸÑÿ© ÿßÿ≥ŸÖ ÿßŸÑÿ®Ÿàÿ™ ÿßŸÑÿÆÿßÿµ.');
        }
    }
});
    
    bot.action('show_current_bot_name', async (ctx) => {
        if (await isDeveloper(ctx, ctx.from.id)) {
            await ctx.answerCbQuery();
            const currentBotName = ctx.botInfo.first_name; // Get the current bot name
            ctx.reply(`ÿßÿ≥ŸÖ ÿßŸÑÿ®Ÿàÿ™ ÿßŸÑÿ≠ÿßŸÑŸä ŸáŸà: ${currentBotName}`);
        }
    });
    
    bot.action('dev_statistics', async (ctx) => {
        if (await isDeveloper(ctx, ctx.from.id)) {
            await ctx.answerCbQuery();
            showStatisticsMenu(ctx);
        }
    });
    
    
    
    
    
    bot.action('dev_developers', async (ctx) => {
        if (await isDeveloper(ctx, ctx.from.id)) {
            await ctx.answerCbQuery();
            showDevelopersMenu(ctx);
        }
    }); 
    // Update the back_to_dev_panel action handler
bot.action('back_to_dev_panel', async (ctx) => {
    const userId = ctx.from.id;

    // Check if this is the first time the /start command is executed
    if (ownerId === null) {
        ownerId = userId; // Set the current user as the owner
        console.log(`Owner set to user ID: ${ownerId}`);
    }

    // Check if the user is a developer or the owner
    const isDev = await isDeveloper(ctx, userId);
    if (isDev || userId === ownerId) {
        await ctx.answerCbQuery();
        showDevPanel(ctx);
    } else {
        ctx.answerCbQuery('‚õî ÿπÿ∞ÿ±Ÿãÿßÿå Ÿáÿ∞Ÿá ÿßŸÑŸÑŸàÿ≠ÿ© ŸÖÿÆÿµÿµÿ© ŸÑŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ ŸÅŸÇÿ∑.', { show_alert: true });
    }
});
    
  
    
   
    
bot.action('list_secondary_developers', async (ctx) => {
    if (await isDeveloper(ctx, ctx.from.id)) {
        await ctx.answerCbQuery('ÿπÿ±ÿ∂ ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ ÿßŸÑÿ´ÿßŸÜŸàŸäŸäŸÜ');
        try {
            const db = await ensureDatabaseInitialized();
            const botId = ctx.botInfo.id; // Get the current bot's ID
            const secondaryDevs = await db.collection('secondary_developers').find({ bot_id: botId }).toArray(); // Filter by bot_id

            if (secondaryDevs.length > 0) {
                const devsList = await Promise.all(secondaryDevs.map(async (dev, index) => {
                    let displayName = dev.username ? `@${dev.username}` : 'ÿ®ÿØŸàŸÜ ŸÖÿπÿ±ŸÅ';
                    try {
                        const user = await ctx.telegram.getChat(dev.user_id);
                        displayName = user.username ? `@${user.username}` : user.first_name || 'ÿ®ÿØŸàŸÜ ÿßÿ≥ŸÖ';
                    } catch (error) {
                        console.error(`Error fetching user info for ${dev.user_id}:`, error);
                    }
                    return `${index + 1}. ${displayName} ‚Ü´ ŸÖÿπÿ±ŸÅ ‚Üì\n${dev.user_id}`;
                }));
                await ctx.reply(`ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ ÿßŸÑÿ´ÿßŸÜŸàŸäŸäŸÜ:\n\n${devsList.join('\n\n')}`);
            } else {
                await ctx.reply('ŸÑÿß ŸäŸàÿ¨ÿØ ŸÖÿ∑Ÿàÿ±ŸäŸÜ ÿ´ÿßŸÜŸàŸäŸäŸÜ ÿ≠ÿßŸÑŸäŸãÿß.');
            }
        } catch (error) {
            console.error('Error fetching secondary developers:', error);
            await ctx.reply('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ¨ŸÑÿ® ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ ÿßŸÑÿ´ÿßŸÜŸàŸäŸäŸÜ. ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ŸÑÿßÿ≠ŸÇŸãÿß.');
            
            // Additional error logging
            console.error('Error details:', error.message);
            console.error('Error stack:', error.stack);
        }
    } else {
        ctx.answerCbQuery('ÿπÿ∞ÿ±Ÿãÿßÿå Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ± ŸÑŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ ŸÅŸÇÿ∑', { show_alert: true });
    }
});

bot.action('delete_secondary_developers', async (ctx) => {
    if (await isDeveloper(ctx, ctx.from.id)) {
        await ctx.answerCbQuery('ÿ≠ÿ∞ŸÅ ÿßŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ ÿßŸÑÿ´ÿßŸÜŸàŸäŸäŸÜ');
        try {
            const db = await ensureDatabaseInitialized();
            const botId = ctx.botInfo.id; // Get the current bot's ID
            const secondaryDevs = await db.collection('secondary_developers').find({ bot_id: botId }).toArray(); // Filter by bot_id

            if (secondaryDevs.length > 0) {
                const keyboard = await Promise.all(secondaryDevs.map(async (dev, index) => {
                    let displayName = dev.username ? `@${dev.username}` : 'ÿ®ÿØŸàŸÜ ŸÖÿπÿ±ŸÅ';
                    try {
                        const user = await ctx.telegram.getChat(dev.user_id);
                        displayName = user.username ? `@${user.username}` : user.first_name || 'ÿ®ÿØŸàŸÜ ÿßÿ≥ŸÖ';
                    } catch (error) {
                        console.error(`Error fetching user info for ${dev.user_id}:`, error);
                    }
                    return [{
                        text: `${index + 1}. ${displayName}`,
                        callback_data: `confirm_delete_secondary_dev_${dev.user_id}`
                    }];
                }));

                keyboard.push([{ text: 'ÿ•ŸÑÿ∫ÿßÿ°', callback_data: 'cancel_delete_secondary_developers' }]);

                await ctx.editMessageText('ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ ÿßŸÑÿ´ÿßŸÜŸàŸäŸäŸÜ:', {
                    reply_markup: { inline_keyboard: keyboard }
                });
            } else {
                await ctx.editMessageText('ŸÑÿß ŸäŸàÿ¨ÿØ ŸÖÿ∑Ÿàÿ±ŸäŸÜ ÿ´ÿßŸÜŸàŸäŸäŸÜ ŸÑÿ≠ÿ∞ŸÅŸáŸÖ.');
            }
        } catch (error) {
            console.error('Error fetching secondary developers for deletion:', error);
            await ctx.editMessageText('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ¨ŸÑÿ® ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ ÿßŸÑÿ´ÿßŸÜŸàŸäŸäŸÜ. ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ŸÑÿßÿ≠ŸÇŸãÿß.');
        }
    } else {
        ctx.answerCbQuery('ÿπÿ∞ÿ±Ÿãÿßÿå Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ± ŸÑŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ ŸÅŸÇÿ∑', { show_alert: true });
    }
});
    
    bot.action(/^confirm_delete_secondary_dev_(\d+)$/, async (ctx) => {
        const devIdToDelete = ctx.match[1];
        if (await isDeveloper(ctx, ctx.from.id)) {
            try {
                const db = await ensureDatabaseInitialized();
                const developer = await db.collection('secondary_developers').findOne({ user_id: parseInt(devIdToDelete) });
                
                if (developer) {
                    const devUsername = developer.username ? `@${developer.username}` : `User ID: ${devIdToDelete}`;
                    await ctx.editMessageText(`ŸáŸÑ ÿ£ŸÜÿ™ ŸÖÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ≠ÿ∞ŸÅ ÿßŸÑŸÖÿ∑Ÿàÿ± ÿßŸÑÿ´ÿßŸÜŸàŸä: ${devUsername}ÿü`, {
                        reply_markup: {
                            inline_keyboard: [
                                [{ text: '‚Ä¢ ÿ≠ÿ∞ŸÅ ‚Ä¢', callback_data: `delete_secondary_dev_${devIdToDelete}` }],
                                [{ text: 'ÿ•ŸÑÿ∫ÿßÿ°', callback_data: 'cancel_delete_secondary_developers' }]
                            ]
                        }
                    });
                } else {
                    await ctx.answerCbQuery('ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖÿ∑Ÿàÿ± ÿßŸÑÿ´ÿßŸÜŸàŸä', { show_alert: true });
                }
            } catch (error) {
                console.error('Error confirming secondary developer deletion:', error);
                await ctx.answerCbQuery('ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ™ÿ£ŸÉŸäÿØ ÿßŸÑÿ≠ÿ∞ŸÅ', { show_alert: true });
            }
        } else {
            ctx.answerCbQuery('ÿπÿ∞ÿ±Ÿãÿßÿå Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ± ŸÑŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ ŸÅŸÇÿ∑', { show_alert: true });
        }
    });
    
    bot.action(/^delete_secondary_dev_(\d+)$/, async (ctx) => {
        const devIdToDelete = ctx.match[1];
        if (await isDeveloper(ctx, ctx.from.id)) {
            try {
                const db = await ensureDatabaseInitialized();
                const result = await db.collection('secondary_developers').deleteOne({ user_id: parseInt(devIdToDelete) });
                
                if (result.deletedCount > 0) {
                    await ctx.editMessageText('ÿ™ŸÖ ÿ≠ÿ∞ŸÅ ÿßŸÑŸÖÿ∑Ÿàÿ± ÿßŸÑÿ´ÿßŸÜŸàŸä ÿ®ŸÜÿ¨ÿßÿ≠.', {
                        reply_markup: {
                            inline_keyboard: [
                                [{ text: 'üîô ÿ±ÿ¨Ÿàÿπ', callback_data: 'back_to_dev_panel' }]
                            ]
                        }
                    });
                } else {
                    await ctx.editMessageText('ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖÿ∑Ÿàÿ± ÿßŸÑÿ´ÿßŸÜŸàŸä ŸÑŸÑÿ≠ÿ∞ŸÅ.', {
                        reply_markup: {
                            inline_keyboard: [
                                [{ text: 'üîô ÿ±ÿ¨Ÿàÿπ', callback_data: 'back_to_dev_panel' }]
                            ]
                        }
                    });
                }
            } catch (error) {
                console.error('Error deleting secondary developer:', error);
                await ctx.editMessageText('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ≠ÿ∞ŸÅ ÿßŸÑŸÖÿ∑Ÿàÿ± ÿßŸÑÿ´ÿßŸÜŸàŸä. ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ŸÑÿßÿ≠ŸÇŸãÿß.', {
                    reply_markup: {
                        inline_keyboard: [
                            [{ text: 'üîô ÿ±ÿ¨Ÿàÿπ', callback_data: 'back_to_dev_panel' }]
                        ]
                    }
                });
            }
        } else {
            ctx.answerCbQuery('ÿπÿ∞ÿ±Ÿãÿßÿå Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ± ŸÑŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ ŸÅŸÇÿ∑', { show_alert: true });
        }
    });
    
    bot.action('cancel_delete_secondary_developers', async (ctx) => {
        if (await isDeveloper(ctx, ctx.from.id)) {
            await ctx.editMessageText('ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿπŸÖŸÑŸäÿ© ÿ≠ÿ∞ŸÅ ÿßŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ ÿßŸÑÿ´ÿßŸÜŸàŸäŸäŸÜ.', {
                reply_markup: {
                    inline_keyboard: [
                        [{ text: 'üîô ÿ±ÿ¨Ÿàÿπ', callback_data: 'back_to_dev_panel' }]
                    ]
                }
            });
        } else {
            ctx.answerCbQuery('ÿπÿ∞ÿ±Ÿãÿßÿå Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ± ŸÑŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ ŸÅŸÇÿ∑', { show_alert: true });
        }
    });
    
   
    
    bot.action('dev_source', async (ctx) => {
        if (await isDeveloper(ctx, ctx.from.id)) {
            await ctx.answerCbQuery();
            showSourceMenu(ctx);
        }
    });
   

    bot.action('dev_replies', async (ctx) => {
        if (await isDeveloper(ctx, ctx.from.id)) {
            await ctx.answerCbQuery();
            showRepliesMenu(ctx);
        }
    });
    
    
    
    

 
    
    
    bot.action('show_active_groups', async (ctx) => {
        try {
            const userId = ctx.from.id;
            const isOwner = ctx.from.username === 'Lorisiv'; // Replace with the actual owner's username
            const isPrimaryDev = await isDeveloper(ctx, userId);
    
            if (!isOwner && !isPrimaryDev) {
                return ctx.answerCbQuery('‚ùå Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ± ŸÖÿÆÿµÿµ ŸÑŸÑŸÖÿßŸÑŸÉ ŸàÿßŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ ÿßŸÑÿ£ÿ≥ÿßÿ≥ŸäŸäŸÜ ŸÅŸÇÿ∑.', { show_alert: true });
            }
    
            await ctx.answerCbQuery('ÿ¨ÿßÿ±Ÿä ÿ¨ŸÑÿ® ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™ ÿßŸÑŸÜÿ¥ÿ∑ÿ©...');
            await ctx.editMessageText('ÿ¨ÿßÿ±Ÿä ÿ¨ŸÑÿ® ÿßŸÑŸÖÿπŸÑŸàŸÖÿßÿ™ÿå Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ±...');
    
            const db = await ensureDatabaseInitialized();
            const activeGroups = await db.collection('active_groups').find().toArray();
    
            let message = 'üìã ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™ ÿßŸÑŸÜÿ¥ÿ∑ÿ©:\n\n';
    
            for (const group of activeGroups) {
                try {
                    const chatInfo = await ctx.telegram.getChat(group.chat_id);
                    const memberCount = await ctx.telegram.getChatMembersCount(group.chat_id);
                    let inviteLink = 'ÿ∫Ÿäÿ± ŸÖÿ™ÿßÿ≠';
                    try {
                        inviteLink = await ctx.telegram.exportChatInviteLink(group.chat_id);
                    } catch (error) {
                        console.log(`Couldn't get invite link for group ${group.chat_id}: ${error.message}`);
                    }
    
                    message += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
                    message += `üìä ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ©:\n`;
                    message += `üè∑ ÿßŸÑÿßÿ≥ŸÖ: ${chatInfo.title}\n`;
                    message += `üîó ÿßŸÑÿ±ÿßÿ®ÿ∑: ${inviteLink}\n`;
                    message += `üÜî ÿßŸÑÿßŸäÿØŸä: \`${group.chat_id}\`\n`;
                    message += `üë• ÿßŸÑÿ£ÿπÿ∂ÿßÿ°: ${memberCount}\n`;
                    message += `üîí ÿßŸÑŸÜŸàÿπ: ${chatInfo.type === 'supergroup' ? (chatInfo.username ? 'ÿπÿßŸÖÿ©' : 'ÿÆÿßÿµÿ©') : chatInfo.type}\n`;
                    message += `üìÖ ÿ¢ÿÆÿ± ŸÜÿ¥ÿßÿ∑: ${new Date(group.last_activity).toLocaleString('ar-EG')}\n`;
                    message += `üìÖ ÿ™ÿßÿ±ŸäÿÆ ÿßŸÑÿ•ÿ∂ÿßŸÅÿ©: ${new Date(group.added_at).toLocaleString('ar-EG')}\n\n`;
    
                    // Information about who added the bot
                    if (group.added_by) {
                        const adderInfo = await ctx.telegram.getChat(group.added_by).catch(() => null);
                        if (adderInfo) {
                            message += `üë§ ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑÿ¥ÿÆÿµ ÿßŸÑÿ∞Ÿä ÿ£ÿ∂ÿßŸÅ ÿßŸÑÿ®Ÿàÿ™:\n`;
                            message += `üè∑ ÿßŸÑÿßÿ≥ŸÖ: ${adderInfo.first_name} ${adderInfo.last_name || ''}\n`;
                            message += `üÜî ÿßŸÑŸÖÿπÿ±ŸÅ: @${adderInfo.username || 'N/A'}\n\n`;
                        }
                    }
    
                    // Group owner information
                    const groupOwner = await ctx.telegram.getChatAdministrators(group.chat_id)
                        .then(admins => admins.find(admin => admin.status === 'creator'))
                        .catch(() => null);
                    if (groupOwner) {
                        message += `üëë ŸÖÿßŸÑŸÉ ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ©:\n`;
                        message += `üè∑ ÿßŸÑÿßÿ≥ŸÖ: ${groupOwner.user.first_name} ${groupOwner.user.last_name || ''}\n`;
                        message += `üÜî ÿßŸÑŸÖÿπÿ±ŸÅ: @${groupOwner.user.username || 'N/A'}\n\n`;
                    }
    
                    // Group admins information
                    const groupAdmins = await ctx.telegram.getChatAdministrators(group.chat_id);
                    if (groupAdmins.length > 0) {
                        message += `üëÆ ÿßŸÑŸÖÿ¥ÿ±ŸÅŸàŸÜ:\n`;
                        for (const admin of groupAdmins) {
                            if (admin.status !== 'creator') { // Skip the owner as we've already listed them
                                message += `üè∑ ${admin.user.first_name} ${admin.user.last_name || ''} (@${admin.user.username || 'N/A'})\n`;
                            }
                        }
                        message += `\n`;
                    }
    
                } catch (error) {
                    console.error(`Error fetching details for group ${group.chat_id}:`, error);
                    message += `‚ùå ÿ™ÿπÿ∞ÿ± ÿ¨ŸÑÿ® ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ© ${group.chat_id}\n\n`;
                }
            }
    
            const replyMarkup = {
                inline_keyboard: [[{ text: 'üîô ÿ±ÿ¨Ÿàÿπ', callback_data: 'back_to_dev_panel' }]]
            };
    
            const maxLength = 4096;
            if (message.length > maxLength) {
                const chunks = message.match(new RegExp(`.{1,${maxLength}}`, 'g'));
                for (let i = 0; i < chunks.length; i++) {
                    if (i === 0) {
                        await ctx.editMessageText(chunks[i], {
                            parse_mode: 'Markdown',
                            disable_web_page_preview: true,
                            reply_markup: i === chunks.length - 1 ? replyMarkup : undefined
                        });
                    } else {
                        await ctx.reply(chunks[i], {
                            parse_mode: 'Markdown',
                            disable_web_page_preview: true,
                            reply_markup: i === chunks.length - 1 ? replyMarkup : undefined
                        });
                    }
                }
            } else {
                await ctx.editMessageText(message, {
                    parse_mode: 'Markdown',
                    disable_web_page_preview: true,
                    reply_markup: replyMarkup
                });
            }
        } catch (error) {
            console.error('Error showing active groups:', error);
            await ctx.answerCbQuery('ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿπÿ±ÿ∂ ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™ ÿßŸÑŸÜÿ¥ÿ∑ÿ©.');
            await ctx.editMessageText('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿπÿ±ÿ∂ ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™ ÿßŸÑŸÜÿ¥ÿ∑ÿ©. ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ŸÑÿßÿ≠ŸÇŸãÿß.', {
                reply_markup: {
                    inline_keyboard: [[{ text: 'üîô ÿ±ÿ¨Ÿàÿπ', callback_data: 'back_to_dev_panel' }]]
                }
            });
        }
    });


    // ‚úÖ Back to the main menu in the same message
  // ‚úÖ Back to the main menu in the same message
  bot.action('back', async (ctx) => {
    try {
        await ctx.answerCbQuery(); // Clear the loading state

        // Check if the user is an admin, owner, or secondary developer
        const isAdmin = await isAdminOrOwner(ctx, ctx.from.id);
        const isSecDev = await isSecondaryDeveloper(ctx, ctx.from.id);

        if (!isAdmin && !isSecDev) {
            return ctx.answerCbQuery('‚ùå Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ± ŸÖÿÆÿµÿµ ŸÑŸÑŸÖÿ¥ÿ±ŸÅŸäŸÜ ŸàÿßŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ ÿßŸÑÿ´ÿßŸÜŸàŸäŸäŸÜ ŸÅŸÇÿ∑.', { show_alert: true });
        }

        await ctx.editMessageCaption(
            'ü§ñ ŸÖÿ±ÿ≠ÿ®Ÿãÿß! ÿ£ŸÜÿß ÿ®Ÿàÿ™ ÿßŸÑÿ≠ŸÖÿßŸäÿ© ŸàÿßŸÑŸÖÿ≥ÿßÿ®ŸÇÿßÿ™ ÿßŸäÿ∂ÿß. ÿßÿÆÿ™ÿ± ÿÆŸäÿßÿ±Ÿãÿß:',
            {
                reply_markup: {
                    inline_keyboard: [
                        [{ text: 'text handle', url: 'https://t.me/ctrlsrc' }],
                        [{ text: 'üìú ÿπÿ±ÿ∂ ÿßŸÑÿ£ŸàÿßŸÖÿ±', callback_data: 'show_commands' }],
                        
                        [{ text: ' ÿ®Ÿàÿ™ ÿßŸÑŸÖÿ≥ÿßÿ®ŸÇÿßÿ™', callback_data: 'quiz_bot' }], // Added quiz bot option
                        [{ text: 'ctrlsrc', url: 'https://t.me/ctrlsrc' }]
                    ]
                }
            }
        );
    } catch (error) {
        console.error('Error in back action:', error);
        await ctx.answerCbQuery('ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿßŸÑÿπŸàÿØÿ© ŸÑŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©.');
    }
});



// ‚úÖ Show list of active groups
async function getActiveGroups(ctx) {
    try {
        const db = await ensureDatabaseInitialized();
        const activeGroups = await db.collection('active_groups').find().toArray();

        if (activeGroups.length === 0) {
            return '‚ùå ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÖÿ¨ŸÖŸàÿπÿßÿ™ ŸÜÿ¥ÿ∑ÿ©.';
        }

        let message = 'üìã ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™ ÿßŸÑŸÜÿ¥ÿ∑ÿ©:\n\n';
        activeGroups.forEach((group, index) => {
            message += `${index + 1}. ${group.chat_title} (ID: ${group.chat_id})\n`;
        });

        return message;
    } catch (error) {
        console.error('Error fetching active groups:', error);
        return '‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ¨ŸÑÿ® ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™ ÿßŸÑŸÜÿ¥ÿ∑ÿ©.';
    }
}

async function getDetailedActiveGroups(ctx) {
    try {
        const db = await ensureDatabaseInitialized();
        const activeGroups = await db.collection('active_groups')
            .find()
            .sort({ last_activity: -1 })
            .toArray();

        if (activeGroups.length === 0) {
            return '‚ùå ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÖÿ¨ŸÖŸàÿπÿßÿ™ ŸÜÿ¥ÿ∑ÿ©.';
        }

        let message = 'üìã ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™ ÿßŸÑŸÜÿ¥ÿ∑ÿ©:\n\n';
        for (const group of activeGroups) {
            try {
                const chatInfo = await ctx.telegram.getChat(group.chat_id);
                const memberCount = await ctx.telegram.getChatMembersCount(group.chat_id);
                let inviteLink = 'ÿ∫Ÿäÿ± ŸÖÿ™ÿßÿ≠';
                try {
                    inviteLink = await ctx.telegram.exportChatInviteLink(group.chat_id);
                } catch (error) {
                    console.log(`Couldn't get invite link for group ${group.chat_id}: ${error.message}`);
                }

                message += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
                message += `üìä ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ©:\n`;
                message += `üè∑ ÿßŸÑÿßÿ≥ŸÖ: ${chatInfo.title}\n`;
                message += `üîó ÿßŸÑÿ±ÿßÿ®ÿ∑: ${inviteLink}\n`;
                message += `üÜî ÿßŸÑÿßŸäÿØŸä: \`${group.chat_id}\`\n`;
                message += `üë• ÿßŸÑÿ£ÿπÿ∂ÿßÿ°: ${memberCount}\n`;
                message += `üîí ÿßŸÑŸÜŸàÿπ: ${chatInfo.type === 'supergroup' ? (chatInfo.username ? 'ÿπÿßŸÖÿ©' : 'ÿÆÿßÿµÿ©') : chatInfo.type}\n`;
                message += `üìÖ ÿ¢ÿÆÿ± ŸÜÿ¥ÿßÿ∑: ${new Date(group.last_activity).toLocaleString('ar-EG')}\n`;
                message += `üìÖ ÿ™ÿßÿ±ŸäÿÆ ÿßŸÑÿ•ÿ∂ÿßŸÅÿ©: ${new Date(group.added_at).toLocaleString('ar-EG')}\n\n`;

                // Information about who added the bot
                if (group.added_by) {
                    const adderInfo = await ctx.telegram.getChat(group.added_by).catch(() => null);
                    if (adderInfo) {
                        message += `üë§ ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑÿ¥ÿÆÿµ ÿßŸÑÿ∞Ÿä ÿ£ÿ∂ÿßŸÅ ÿßŸÑÿ®Ÿàÿ™:\n`;
                        message += `üè∑ ÿßŸÑÿßÿ≥ŸÖ: ${adderInfo.first_name} ${adderInfo.last_name || ''}\n`;
                        message += `üÜî ÿßŸÑŸÖÿπÿ±ŸÅ: @${adderInfo.username || 'N/A'}\n\n`;
                    }
                }

                // Group owner information
                const groupOwner = await ctx.telegram.getChatOwner(group.chat_id).catch(() => null);
                if (groupOwner) {
                    message += `üëë ŸÖÿßŸÑŸÉ ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ©:\n`;
                    message += `üè∑ ÿßŸÑÿßÿ≥ŸÖ: ${groupOwner.user.first_name} ${groupOwner.user.last_name || ''}\n`;
                    message += `üÜî ÿßŸÑŸÖÿπÿ±ŸÅ: @${groupOwner.user.username || 'N/A'}\n\n`;
                }

                // Group admins information
                const groupAdmins = await ctx.telegram.getChatAdministrators(group.chat_id);
                if (groupAdmins.length > 0) {
                    message += `üëÆ ÿßŸÑŸÖÿ¥ÿ±ŸÅŸàŸÜ:\n`;
                    for (const admin of groupAdmins) {
                        if (admin.status !== 'creator') { // Skip the owner as we've already listed them
                            message += `üè∑ ${admin.user.first_name} ${admin.user.last_name || ''} (@${admin.user.username || 'N/A'})\n`;
                        }
                    }
                    message += `\n`;
                }

                message += `\n`;
            } catch (error) {
                console.error(`Error fetching details for group ${group.chat_id}:`, error);
                message += `‚ùå ÿ™ÿπÿ∞ÿ± ÿ¨ŸÑÿ® ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ© ${group.chat_id}\n\n`;
            }
        }

        return message;
    } catch (error) {
        console.error('Error fetching detailed active groups:', error);
        return '‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ¨ŸÑÿ® ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™ ÿßŸÑŸÜÿ¥ÿ∑ÿ©.';
    }
}
async function updateGroupInfo(ctx) {
    if (ctx.chat.type === 'group' || ctx.chat.type === 'supergroup') {
        try {
            const db = await ensureDatabaseInitialized();
            const chatId = ctx.chat.id;
            const chatTitle = ctx.chat.title;
            const memberCount = await ctx.telegram.getChatMembersCount(chatId);
            let inviteLink = null;

            try {
                inviteLink = await ctx.telegram.exportChatInviteLink(chatId);
            } catch (error) {
                console.log(`Couldn't get invite link for group ${chatId}: ${error.message}`);
            }

            await db.collection('active_groups').updateOne(
                { chat_id: chatId },
                {
                    $set: {
                        chat_title: chatTitle,
                        member_count: memberCount,
                        last_activity: new Date(),
                        invite_link: inviteLink
                    },
                    $setOnInsert: {
                        added_at: new Date(),
                        added_by: ctx.from.id
                    }
                },
                { upsert: true }
            );

            console.log(`Updated group info for ${chatTitle} (${chatId})`);
        } catch (error) {
            console.error('Error updating group info:', error);
        }
    }
}
// Add this function to get the custom bot name for a chat

async function getCustomBotName(chatId) {
    try {
        const db = await ensureDatabaseInitialized();
        const customName = await db.collection('bot_names').findOne({ chat_id: chatId });
        
        if (customName) {
            return customName.name;
        }
        return null;
    } catch (error) {
        console.error('Error retrieving custom bot name:', error);
        return null;
    }
}   
//check this later maybe its not saving the replays because of this 
async function sendReply(ctx, reply) {
    try {
        if (reply.type === 'text') {
            await ctx.reply(reply.text || reply.reply_text, { reply_to_message_id: ctx.message.message_id });
        } else if (reply.type === 'text_cycle') {
            const texts = reply.reply_texts;
            if (texts && texts.length > 0) {
                const currentIndex = reply.cycle_index || 0;
                const textToSend = texts[currentIndex];

                console.log(`Current index: ${currentIndex}, Text to send: ${textToSend}`);

                await ctx.reply(textToSend, { reply_to_message_id: ctx.message.message_id });

                const newIndex = (currentIndex + 1) % texts.length;
                console.log(`New index: ${newIndex}`);

                const db = await ensureDatabaseInitialized();
                await db.collection('replies').updateOne(
                    { _id: reply._id },
                    { $set: { cycle_index: newIndex } }
                );
            } else {
                console.error('No valid texts found in reply_texts for text_cycle type.');
                await ctx.reply('‚ùå ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÜÿµŸàÿµ ÿµÿßŸÑÿ≠ÿ© ŸÑŸÑÿ±ÿØ.', { reply_to_message_id: ctx.message.message_id });
            }
        } else if (reply.type === 'media') {
            switch (reply.media_type) {
                case 'photo':
                    await ctx.replyWithPhoto(reply.file_id, { reply_to_message_id: ctx.message.message_id });
                    break;
                case 'blank':
                    await ctx.replyWithVideo(reply.file_id, { reply_to_message_id: ctx.message.message_id });
                    break;
                case 'animation':
                    await ctx.replyWithAnimation(reply.file_id, { reply_to_message_id: ctx.message.message_id });
                    break;
                case 'document':
                    await ctx.replyWithDocument(reply.file_id, { reply_to_message_id: ctx.message.message_id });
                    break;
                case 'sticker':
                    await ctx.replyWithSticker(reply.file_id, { reply_to_message_id: ctx.message.message_id });
                    break;
                default:
                    console.error('Unknown media type:', reply.media_type);
                    await ctx.reply('‚ùå ŸÜŸàÿπ Ÿàÿ≥ÿßÿ¶ÿ∑ ÿ∫Ÿäÿ± ŸÖÿØÿπŸàŸÖ.', { reply_to_message_id: ctx.message.message_id });
            }
        } else {
            console.error('Unknown reply type:', reply.type);
            await ctx.reply('‚ùå ŸÜŸàÿπ ÿßŸÑÿ±ÿØ ÿ∫Ÿäÿ± ŸÖÿπÿ±ŸàŸÅ.', { reply_to_message_id: ctx.message.message_id });
        }
    } catch (error) {
        console.error('Error sending reply:', error);
        await ctx.reply('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ±ÿØ.', { reply_to_message_id: ctx.message.message_id });
    }
}


bot.action('check_subscription', forceCheckSubscription);






// Add this closing brace to close the setupActions function
}

module.exports = { setupActions,
    activeQuizzes,endQuiz , ensureDatabaseInitialized,configureQuiz,startAddingCustomQuestions,chatStates,forceCheckSubscription,confirmSubscription, };
